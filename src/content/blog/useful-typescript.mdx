---
title: Useful TypeScript Helpers
description: Useful functions and type helpers for TypeScript
date: 2023-09-07T03:18:13.471Z
updated: 2024-02-24T17:20:12.773Z
image: $/assets/images/typescript.png
tags:
  - TypeScript
---
import Collapsible from "$/components/markdown/collapsible.astro";
import Tweet from "$/components/markdown/tweet.astro";

## Table of Contents

## Type Declarations

### View Transition

The `startViewTransition` function is a method on the `document` object which enables view transitions. The following types are based on the documentation at MDN. Since the API is currently experimental, you may need to add the following type to your type declaration file to avoid errors. 

<div class="button-row">
  [Google Article](btn::https://developer.chrome.com/docs/web-platform/view-transitions/)
  [MDN](btn::https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition)
</div>

```typescript
declare global {
	interface ViewTransition {
		/**
		 * A Promise that fulfills once the transition animation is finished, 
		 * and the new page view is visible and interactive to the user.
		 */
		finished: Promise<void>;
		/**
		 * A Promise that fulfills once the pseudo-element tree is created 
		 * and the transition animation is about to start.
		 */
		ready: Promise<void>;
		/**
		 * A Promise that fulfills when the promise returned by the 
		 * document.startViewTransition()'s callback fulfills.
		 */
		updateCallbackDone: Promise<void>;
		/**
		 * Skips the animation part of the view transition, but doesn't skip 
		 * running the document.startViewTransition() callback that updates the DOM.
		 */
		skipTransition: () => void;
	}

	type ViewTransitionCallback = (() => Promise<void>) | (() => void);

	interface Document {
		startViewTransition: (callback: ViewTransitionCallback) => ViewTransition;
	}
}
```

<Collapsible title="Using in SvelteKit">
  In SvelteKit, you can add the above type declaration to a file in the `src` directory, such as `src/types.d.ts`. Then you can add view transitions to your SvelteKit app by following the video below, ignoring the `@ts-ignore` comments.

  [YouTube](embed::https://www.youtube.com/watch?v=q_2irZO4SS8)
</Collapsible>

## Prettify

The `Prettify` type is a simple type which takes an object type with intersections and combines them to make them easier to read.

```ts
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
```

<div class="grid sm:grid-cols-2 gap-4">
  <Tweet link="https://twitter.com/mattpocockuk/status/1622730173446557697" />
  <Tweet link="https://twitter.com/mattpocockuk/status/1622730175266926592" />
  <Tweet link="https://twitter.com/mattpocockuk/status/1622730176931983360" />
  <Tweet link="https://twitter.com/mattpocockuk/status/1622730179289251840" />
</div>

## Combine Two Object Types

The `Combine` type is a simple type which takes 2 object types and combines them into one.

<div class="button-row">
  [Playground](btn::https://www.typescriptlang.org/play?#code/PTAEGEHkBEFECh4BcCeAHApqACgJw0kgJYBmKAPACoB8oAvKAN7yigDaA0qEQHagDWGFAHsSoSgF0AXOM4SA3PAC+oAGRMli5OizhhAWwBGvDFQCMAGnEAmWgzwFiZciyavWnbn0EixACkozUAAfGwBKaXEzORCbOUVWFXVsAENcYhSAG3M1G2p4ai0QcVgAZUpSxCJ9NGF0plBYAEcAVyyrWAAPTABjJFAVElwDUAAiAAEkYSQsgFpUTABnHtwiNCRgAAsMTMxcRdGtBaxKHQBBejdWfBSAE2EeTJRQHhT9DBlFpFWeAHME0A3e6PZ53W74RaLT7fXj-ZRHHTiHQAIUujEBGDuDyeLzeH1AXx+-1AaE2D3xhNhAwRmFAACUMIsWpl+gw9EYTFRzlZTphkYVEMdGt0MH0MLc0a4gdjnq93tCiQDpSDQGCIYsAPwK2EA0nkrUEmF-RSaQWIpCM1nC3pIcjNNrZBlMlkdEVi27UAVAA)
</div>

```ts
type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};

type Combine<T1, T2> = Prettify<
  {
    [K in keyof (T1 | T2)]: T1[K] | T2[K];
  } & Partial<T1 & T2>
>;
```

<div class="grid sm:grid-cols-2 gap-4">
  <Tweet link="https://twitter.com/mattpocockuk/status/1712391832573718721" />
</div>

## SuperStruct

The `SuperStruct` type is a utility type that transforms the properties of an object to an alternative provided type. It is used by [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms) to transform the properties of a form schema to a type used for validation errors.

<div class="button-row">
  [Playground](btn::https://www.typescriptlang.org/play?#code/PTAEGEHkBEFECh4FMAeAHA9gJwC6hwJ5pKgDKArsVqTluQMY4CCWWAhgQDwAqoqOSAHYATAM6gASknrZhnUbQCWggOYAaUOUEBrQRgDuggHwbobHGw0t2BMxdABeTTr2Gjj0AG94ASBB9RABtlHABaYUVRNgAjQKRQwX5Q4MTQAAFCYlF6LEU0MKQgkOA9UNQ0YPpFMLZBAl8AbQAFLAwqQlBlUG0kAgwAM1BuAF0AfgAuIb4UARFxWvqfH1Gh5tb2gmHp2bFJaVl5JVUNLV0DY18llYoqGjpGaw4eNbakXE3Tc0tQR9svo0uPkm3BeGy2-CEuwAFMp+m8fgBKBrDQHLH6sDh2NigABkexkWDkgnIAFtom8rNtIeIpAS5ApcsdnGc3KBrpQ3ncGMwMVwmJ8LFZeVj3JMRaixV9LpNEgA3N4AbngAF8lch0Ng8JkSDdObRuTwqXN8QcGcp1MzXMYBWx3E4mmxcIo2IFON4-GBCikwhEorF4okZsllCQMkRCjk8gUioIcCUMGV0JVqqEFo0Wq93p1BN1egMhsNgUbdmmrqsM2DizT9oTDoyLacrQClmjddR9YxnhW3oRhjbm0tgaCe5sq6AYYI4VhEcjUSsmGPaaajg2XOcBy32bcOzhOPzQOKW4OD1Kj5KLNLQHLFSqjGr-NxYKRuKREIoSZhcF5QLAAI7kF0NFgdBpDwZVQH6VoSVAAAiDIMAsQJQm1bJcnyYAAAskECKhRBgtVtVAAAZDAVCxDxvFATphBlUlySwJUqJJQoohUJBJjNVRGNAYRzHY0BOJUbjyFEN5JkoqjqNoskb0kq82GYjiV241V4CoiwVFEJT62RJVlUQQiSJUWBWGwUQFycNsuQeXlOCMrENEE5E73gfwqIAPVGeBDNIkzWiwUQACEPCsnc7NIhyBJXZylTc0BPIM8MhkKZgPGA4hOz-ADXSMvyzKYBoYMUYQYL7KKdK2AAfZxhCQfoQ2EIwXLihLCO4FLgqcdLQM4LKXXC4zTICwLCuK0rHOiqqarqhqmtisAPK8+AZEEBQ+CGrTiN8jbOq8NTNFErBxP2qjismQq8unZjRFYpBSv2-TVSAA)
  [Source](btn::https://github.com/ciscoheat/sveltekit-superforms/blob/main/src/lib/superStruct.ts)
</div>

```ts
export type SuperStructArray<T extends Record<string, unknown>, Data, ArrayData = unknown> = {
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	[Property in keyof T]?: T extends any
		? NonNullable<T[Property]> extends Record<string, unknown>
			? SuperStructArray<NonNullable<T[Property]>, Data, ArrayData>
			: NonNullable<T[Property]> extends (infer A)[]
				? ArrayData &
						Record<
							number,
							NonNullable<A> extends Record<string, unknown>
								? SuperStructArray<NonNullable<A>, Data, ArrayData>
								: Data
						>
				: Data
		: never;
};

export type SuperStruct<T extends Record<string, unknown>, Data> = Partial<{
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	[Property in keyof T]: T extends any
		? NonNullable<T[Property]> extends Record<string, unknown>
			? SuperStruct<NonNullable<T[Property]>, Data>
			: NonNullable<T[Property]> extends (infer A)[]
				? NonNullable<A> extends Record<string, unknown>
					? SuperStruct<NonNullable<A>, Data>
					: Data
				: Data
		: never;
}>;
```

### Example

```ts
type LogData = {
  id: number;
  message: string;
  date: string;
  user: {
    id: number;
    name: string;
  };
  tags: string[];
}

type LogErrors = SuperStructArray<LogData, string[]>;

// LogErrors["id"] => string[] | undefined
// LogErrors["message"] => string[] | undefined
// LogErrors["date"] => string[] | undefined
// LogErrors["user"] => SuperStructArray<LogData["user"], string[]> | undefined
// Exclude<LogErrors["user"], undefined>["id"] => string[] | undefined
// etc.
```

## FormPathLeaves

The `FormPathLeaves` type is a utility type that takes an object type and returns a union of all the leaf paths of the object. It has an optional second parameter to specify the type (ex. `Date` or `number`) of paths to return. This is also used by [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms).

<div class="button-row">
  [Playground](btn::https://www.typescriptlang.org/play?ssl=39&ssc=1&pln=236&pc=42#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-OCMCkFEAwVIuQb0NguzzEhi2KkiqvRVE-wtoMT5zyxnlQmZk4ZSlgV5Pqk1bsLVgU1KQeojcEKWmDSqT0DegKqnrCfIS9mEZapxgTJzCQ7zQC9IeJ8pEDU6UNXlaUopOYGVxCVaAOFDUTZ-JeBi58392ZNGUIuDR0kWirAhT8CFEKcwyrlY1Flk5NXONAFY6YtjtW6uCEibVzqmB6vpCrAQWV9W2p6PavpjqFWQIEJqgphdVXQMZX6qltydU3D+cG9cYakWRtAE0PE0QCTdmIAHB40kqyjItvm615Lh43H6RG21xb2ClriOWp6laXiDBbRC5S-aIV0rYNqxVoQ60RoDaO9NXyGoBr+dyodLS-HUG9Vm4IHhAj+IZIIDwwQkmTttRvbVCKl0tvWEO8NLa2AOtnfKxVyqp4VNTaAVd67oR-K3Tuwke6D05sORAF4LRgXdAjapNykBLyTFTA8LsGlP69taSobSbA20dq7RgE8EFgjVqNdeWtLabX9qjc2odcqj0QvnTPBWLq+1DucZRnoHqbEFg-dcbNWrZ3fIXbh+j-bAX8ZbeBP8R76DXpbTmdDnAy0VpE7hslJr2BmqBhaq1RHKOkZjY+6BhTylquakiFjXruOZs-b638SHBMQBwxJyThbpOye7VWslZyywVnU0O5FMqmO2oo15iNsbJbxqE0OxNsD9Mpo1aF-txm2OmZ9UiVdPZv3UF3QIfd3je2+YhYJnLPR5M5bs-229fT8v+YC1Rx9+WSnPoM6m-LcXZUJY3Ul-xKXt1pd-Rlg92XKu5ZDTFlt0kisga8zmItJaZOdorS5mt7dfOzjxU2-LjmZvOb6-1wd-WR1caGRm8d56AvTr21knjNG56Lvyz0FpTX2OceS6l9LmX0T9YhSe0zZ78uXsq8Vm9bKxv-YkVIlA2G-x4bUUYo9s47stfM8ZI9LAmOkZyxVgLQW6pKpy+qrH-XYf7bnYlyzQ3bVuYuWS+Tmj8dnbMxxizPYqzIJJxCwrAXxPI4bWAlb-W1uYbB3xnL22Au7bHXGq7b2Tv+ou4rcX-XbvWJMwT75ROGdHaHR9pXPy-iy4Cz9od7OgfRvvY1HTtWIaRZx0ZhX8XNcq6s4Nmz4Ol1bqg4oG+BZ4N3i0kiPu2lYJ01igzV+NxsqVQuGS33xxw-zIXMucAUrwIXERZC3SZL0vArAqB1PozvEEX8aajRAAlSQSBElItnBXa4ofedyaQ8XhQEm2DR-w2CVdz3gj5+U0XkvZeI2zhr92ocimC+qctcnvvJxg-QlD9JJE9ekDFbMN+fYcpmAJxNrkJvrVsra2AvmpvZLV0j9-Kl4-8-e8T-PDHxZoAB9YaHJOivU+q-Hjvw+HDc+S9-bYJX0PYt5+L7Z4t5vqd4qYn557UBn497eKP6-hkoLJLi35TZOb35-bIq-6v7IHraoEf6gAAGI5IHtrTZ85D6jJKZgFqbj79pP6Qgh7Hiz54Ff6UZL7KAr5xBr4mw2hb7-y75662oH456dbH4pbBAQFQEKAX5EZwEArdaUZgTD5d6j6ebUGT60HT70Gf4N5MYsHsBsEcE3BcLcE74rh8ERoCHAFt7daSEqFv6kHAHkHmpj6LagAjaVY6F6FMDr43COhGF-C8HaFAFqIIHLi2FoG2r95YEkEvB3JUFDrmFqKWG2AZYwH9YRFEEoGKRkHH6UH5aziuH9buGr6eEmzsK+GYD+EFFVSsFFFeHQg8JlEjR75xGBE-yDRyEQDMEtHsye6aQPhMaziSRMQYCyTyTv5J4BEfjVHsHFE3DMING8GwSLhFipjyTIj5jQp2L0BCrXjF5RACBMAPBupk4VjZb0DN5qKV78hDjtDShkoYGGRiwXD6ovBNDpTaxIgtIXBIhsEKhQoGJZBIyFpsiIEmyUAUBUBlB9xeg5IWCgBRAxCthoAzSxBUAmwEQSBoDsFIBNBlAERej2BwnDKtidoKB3jHBIm2QETNhoCtAEnwnGy4DKB1TknIlIAESzLkyKiiCwlNA3wRA8AyakBnBL6BANh1IqA6SATARIj8mNyvgyhyi-HIabQNLdYGIUBVhZCwmWDLi8lBQCmdqoQCCBCylwzsAKkmhPLgmnKTgYA1TKxMAgbanal8kGlCnGmmnynQpWk0DhDOn0BwxICUyLT6ncCClGkmmUxmkWkKgTrOkeDtCwnpTcmgDeiwmAlNDAnLgklIBkkACE4JowRYeE9pDy0JWpFgzYTJgggQOZd4PpPxdYzpgZwZHMBJ6w9AHZoALZAgHkSYYQQAA)
  [Source](btn::https://github.com/ciscoheat/sveltekit-superforms/blob/main/src/lib/stringPath.ts)
</div>

```ts
type BuiltInObjects = Date | Set<unknown> | File;

export type AllKeys<T> = T extends T ? keyof T : never;

export type PickType<T, K extends AllKeys<T>> = T extends { [k in K]: any } ? T[K] : never;

// Thanks to https://dev.to/lucianbc/union-type-merging-in-typescript-9al
export type MergeUnion<T> = {
	[K in AllKeys<T>]: PickType<T, K>;
};

/**
 * Lists all paths in an object as string accessors.
 */
export type FormPath<T extends object, Type = any> = string &
	StringPath<T, { filter: 'all'; objAppend: never; path: ''; type: Type }>;

/**
 * List paths in an object as string accessors, but only with non-objects as accessible properties.
 * Similar to the leaves in a node tree, if you look at the object as a tree structure.
 */
export type FormPathLeaves<T extends object, Type = any> = string &
	StringPath<T, { filter: 'leaves'; objAppend: never; path: ''; type: Type }>;

/**
 * List paths in an object as string accessors, but only with non-objects as accessible properties.
 * Also includes the _errors field for objects and arrays.
 */
export type FormPathLeavesWithErrors<T extends object, Type = any> = string &
	StringPath<T, { filter: 'leaves'; objAppend: '_errors'; path: ''; type: Type }>;

/**
 * List all arrays in an object as string accessors.
 */
export type FormPathArrays<T extends object, Type = any> = string &
	StringPath<T, { filter: 'arrays'; objAppend: never; path: ''; type: Type }>;

// Thanks to https://stackoverflow.com/a/77451367/70894
type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;

type Concat<
	Path extends string,
	Next extends string
> = `${Path}${Path extends '' ? '' : '.'}${Next}`;

type StringPathOptions = {
	filter: 'arrays' | 'leaves' | 'all';
	objAppend: string | never;
	path: string;
	type: any;
};

type If<
	Options extends StringPathOptions,
	Pred extends keyof Options,
	Subj,
	Then,
	Else = never,
	Value = unknown
> = Options[Pred] extends Subj
	? Options['type'] extends never
		? Then
		: Value extends Options['type']
			? Then
			: never
	: Else;

type StringPath<
	T extends object,
	Options extends StringPathOptions = {
		filter: 'all';
		objAppend: never;
		path: '';
		type: never;
	}
> = T extends BuiltInObjects
	? If<Options, 'filter', 'leaves' | 'all', Options['path']>
	: T extends (infer U)[]
		?
				| If<Options, 'objAppend', string, Concat<Options['path'], Options['objAppend']>, never, T>
				| If<Options, 'filter', 'arrays' | 'all', Options['path'], never, T>
				| (NonNullable<U> extends object
						? StringPath<
								NonNullable<U>,
								{
									filter: Options['filter'];
									objAppend: Options['objAppend'];
									path: `${Options['path']}[${number}]`;
									type: Options['type'];
								}
							>
						: If<Options, 'filter', 'leaves' | 'all', `${Options['path']}[${number}]`, never, T>)
		: {
				[K in Extract<AllKeys<T>, string>]: NonNullable<T[K]> extends object
					?
							| If<
									Options,
									'objAppend',
									string,
									Concat<Options['path'], Options['objAppend']>,
									never,
									T[K]
							  >
							| NonNullable<T[K]> extends (infer U)[]
						?
								| If<Options, 'filter', 'arrays' | 'all', Concat<Options['path'], K>, never, T[K]>
								| (NonNullable<U> extends unknown[]
										? If<
												Options,
												'filter',
												'arrays' | 'all',
												Concat<Options['path'], `${K}[${number}]`>,
												never,
												T[K]
											>
										: If<
												Options,
												'filter',
												'leaves' | 'all',
												Concat<Options['path'], `${K}[${number}]`>,
												never,
												U
											>)
								| (NonNullable<U> extends object
										? StringPath<
												NonNullable<U>,
												{
													filter: Options['filter'];
													objAppend: Options['objAppend'];
													path: Concat<Options['path'], `${K}[${number}]`>;
													type: Options['type'];
												}
											>
										: never)
						: IsAny<T[K]> extends true
							? Concat<Options['path'], K>
							:
									| If<
											Options,
											'filter',
											'all',
											Concat<Options['path'], K>,
											unknown extends T[K] ? Concat<Options['path'], K> : never,
											T[K]
									  >
									| StringPath<
											NonNullable<T[K]>,
											{
												filter: Options['filter'];
												objAppend: Options['objAppend'];
												path: Concat<Options['path'], K>;
												type: Options['type'];
											}
									  >
					: If<Options, 'filter', 'leaves' | 'all', Concat<Options['path'], K>, never, T[K]>;
			}[Extract<AllKeys<T>, string>];

export type FormPathType<T, P extends string> = P extends keyof T
	? T[P]
	: P extends number
		? T
		: P extends `.${infer Rest}`
			? FormPathType<NonNullable<T>, Rest>
			: P extends `${number}]${infer Rest}`
				? NonNullable<T> extends (infer U)[]
					? FormPathType<U, Rest>
					: { invalid_path1: P; Type: T }
				: P extends `${infer K}[${infer Rest}`
					? K extends keyof NonNullable<T>
						? FormPathType<NonNullable<T>[K], Rest>
						: FormPathType<T, Rest>
					: P extends `${infer K}.${infer Rest}`
						? K extends keyof NonNullable<T>
							? FormPathType<NonNullable<T>[K], Rest>
							: NonNullable<T> extends (infer U)[]
								? FormPathType<U, Rest>
								: { invalid_path2: P; Type: T }
						: P extends `[${infer K}].${infer Rest}`
							? K extends number
								? T extends (infer U)[]
									? FormPathType<U, Rest>
									: { invalid_path3: P; Type: T }
								: P extends `${number}`
									? NonNullable<T> extends (infer U)[]
										? U
										: { invalid_path4: P; Type: T }
									: P extends keyof NonNullable<T>
										? NonNullable<T>[P]
										: P extends `${number}`
											? NonNullable<T> extends (infer U)[]
												? U
												: { invalid_path5: P; Type: T }
											: { invalid_path6: P; Type: T }
							: P extends ''
								? T
								: P extends AllKeys<T>
									? MergeUnion<T>[P]
									: { invalid_path7: P; Type: T };
```

### Example

```ts
type LogData = {
  id: number;
  message: string;
  date: Date;
  user: {
    id: number;
    name: string;
  };
  tags: string[];
}

type LogLeaves = FormPathLeaves<LogData>;
//   ^? "id" | "message" | "date" | "user.id" | "user.name" | `tags[${number}]`
type LogNumberLeaves = FormPathLeaves<LogData, number>;
//   ^? "id" | "user.id"
```

### Set Nested Value

Below is a `setValue` function which takes an object, a path, and a value. The path is a string of dot-separated keys. The function should set the value at the given path. The path parameter will have autocomplete and the value parameter will be required to be of the same type as the property at that path. See the playground for examples. This function works very similarly to [lodash.set](https://lodash.com/docs/4.17.15#set), but with stronger type safety.

```typescript
function setValue<
  T extends Record<string, unknown>,
  P extends FormPathLeaves<T>,
  V extends FormPathType<T, P>
>(obj: T, path: P, value: V) {
  if (typeof path === "string") {
    const pList = path.split(".");
    const lastKey = pList.pop();
    const pointer = pList.reduce(
      (accumulator: { [x: string]: any }, currentValue: string | number) => {
        if (accumulator[currentValue] === undefined)
          accumulator[currentValue] = {};
        return accumulator[currentValue];
      },
      obj
    );
    if (typeof lastKey !== "undefined") {
      pointer[lastKey] = value;
      return obj;
    }
  }
  return obj;
}
```