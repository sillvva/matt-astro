---
title: TypeScript Helpers from Superforms
description: Utility types from the Superforms library and how to use them.
date: 2024-03-12T22:23:39.398Z
image: $/assets/images/typescript.png
tags:
  - TypeScript
---
import Collapsible from "$/components/markdown/collapsible.astro";

## Table of Contents

## Superforms Types

The types in this post were created mostly by Andreas Söderlund, the creator of [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms), and are useable under the MIT license which must be included with all copies.

<Collapsible title="MIT License">
Copyright (c) 2023 Andreas Söderlund

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</Collapsible>

### SuperStruct

The `SuperStruct` type is a utility type that transforms the properties of an object to an alternative provided type. It is used by [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms) to transform the properties of a form schema to a type used for validation errors.

<div class="button-row">
	[Playground](btn::https://www.typescriptlang.org/play?#code/PTAEBUFEGV2goeBLAtgBwPYCcAuoDeokAjgK4CGANgDREAeaApgMZ4C+oAZlhiqAEQABHBhxUAtDgCeTAM7MsSNDmAALRpSZZZ-ANyJpTUABkMAcwAi5MaAC8BeKFBIAJgC5QAO1IoARoyx9JxRGWVlyM0YPWRxFTzMg0BdrKNAYuITHUFJZAI98LKdXD28-AMSnT3IQ6NikeMS2RLEzWVqMgG0AXX02AxlGE3NILB5tO1BoUi1oWNJWAB5TS2tyWnT6s26APn0QJ1AAPQB+fqNwULx7SAYWHAWSCkol4dHsWQ7+V34u9br47qgAA+2U8LkYnHqjBc2128H2ThOiGYGE8MVAATGbSGZhGWImBScOTyDgOzncoE+eOwoBCYQijB+WT6TUQ+wAwgB5CyQRCMBjYPCGQYAQUolAA0owpLIFuBthNwBi6DhGGDZBBQMdQABraUYTiakqMABu5TZYFClHqOHELiQ4V8lEY4k8-Nt1rdoGEA3kimU4itNuAngwgYY1uYSFt5E8UngwtAAAUkMwdeABnLaBLlar1aAxZLpbL5Qr7Er3WqXBrCB0dc5PKAJV0PLGpKAONrwB1m6BjWbAhaIKpYzqNSJQKocDg0G0QOCTQA6ETASjzJCx3zMYCkTxIVGSAbiEJYMybcT1Q9yBRKW0ATio8H5mFwoETAFkApEAKp71FyssHAASB7BsC3FKUZQAltk1TdNM3AbM4VZJ8BVfRMphmOZWBFUZyCkOVcyrDUACUWGwFwFg2eJaF3HVQwAd08bZaCsMRaFwrB8LY8gJjoxjmIJeAgP2INPFte1HWdV13XET1Bh9a9-VtMSVFDcM0EjaNxDbYSOiTHgtGkMDC0gktti6Y4PA6cAuiI-MOjbLphKA7UADlUTc0hxXIJ1GDlfTDICaQugVSt8zIlEsEo6izFozx6IwJjthc1zJmmAJZiweYcE4-CFk-U9GF-fdPAWDzPC8ny-ICgyMCMqRQpY0AeI4vCpB4lKgO6jwKqqyhfOdWqgtwRqwpVYjQAACnqTgAgLABKbpUrSvKOtWUAADIVu6yKKIWHbutKfwsGBNJ-jiw6gL67yBpqkVxrzatQD26KqIu+LEuSq60swzLsNy9qCq-Yq-zKm7qqGh7mtagt2s6n6PB4w6uu6oCkdWFz+3NFDn0FN8BnSrDssWCsJoi8i3tiz6BJh1ZAKTchcA3Z4ChEy1ZE9CSHUGl03RVOSoW9YU-VvQNOeDdTny0mM4z0uqGpMiDi2g6zbPs57HLjZzuvczzbt54b6uCsaNdIymYo+0EvuY1LtT+rAspy4GipK-8IbuobuwVk2mtY+nUt6-XIf872RpCx7Jpmzw5tOkUlp1tG9cqg37sjimostjIaaS220d1on-pJ+5Cp-MHyuDz3-Oh-2xFRtGMbEFbG-ILGvFNHHdiAA)
  [Source](btn::https://github.com/ciscoheat/sveltekit-superforms/blob/main/src/lib/superStruct.ts)
</div>

```ts
export type AllKeys<T> = T extends T ? keyof T : never;

type PickType<T, K extends AllKeys<T>> = T extends { [k in K]: infer Item } ? Item : never;

// Thanks to https://dev.to/lucianbc/union-type-merging-in-typescript-9al
export type MergeUnion<T> = {
	[K in AllKeys<T>]: PickType<T, K>;
};

export type SuperStructArray<T extends Record<string, unknown>, Data, ArrayData = unknown> = {
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	[Property in AllKeys<T>]?: [T] extends [any]
		? NonNullable<T[Property]> extends Record<string, unknown>
			? SuperStructArray<MergeUnion<NonNullable<T[Property]>>, Data, ArrayData>
			: NonNullable<T[Property]> extends (infer A)[]
				? ArrayData &
						Record<
							number | string,
							NonNullable<A> extends Record<string, unknown>
								? SuperStructArray<MergeUnion<NonNullable<A>>, Data, ArrayData>
								: Data
						>
				: Data
		: never;
};

export type SuperStruct<T extends Record<string, unknown>, Data> = Partial<{
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	[Property in AllKeys<T>]: [T] extends [any]
		? NonNullable<T[Property]> extends Record<string, unknown>
			? SuperStruct<MergeUnion<NonNullable<T[Property]>>, Data>
			: NonNullable<T[Property]> extends (infer A)[]
				? NonNullable<A> extends Record<string, unknown>
					? SuperStruct<MergeUnion<NonNullable<A>>, Data>
					: Data
				: Data
		: never;
}>;
```

#### Example

```ts
type LogData = {
  id: number;
  message: string;
  date: string;
  user: {
    id: number;
    name: string;
  };
  tags: string[];
}

type LogErrors = SuperStruct<LogData, string[]>;

// [!code word:string\[\]:9]
// Converts each property to string[] | undefined
// LogErrors["id"] => string[] | undefined

// Converts objects into a partial with each property as string[] | undefined
// LogErrors["user"] => Partial<{ id: string[], name: string[] }> | undefined
// Exclude<LogErrors["user"], undefined>["id"] => string[] | undefined

// Converts the tags array itself to string[] | undefined
// LogErrors["tags"] => string[] | undefined

type LogErrors = SuperStructArray<LogData, string[]>;

// [!code word:string\[\]:9]
// Converts each property to string[] | undefined
// LogErrors["id"] => string[] | undefined

// Converts objects into an object with the same SuperStructArray type
// LogErrors["user"] => SuperStructArray<LogData["user"], string[]> | undefined
// Exclude<LogErrors["user"], undefined>["id"] => string[] | undefined

// Converts each value in the tags array to a string[] type
// LogErrors["tags"] => Record<number, string[]> | undefined
```

### FormPathLeaves

The `FormPathLeaves` type is a utility type that takes an object type and returns a union of all the leaf paths of the object. It has an optional second parameter to specify the type (ex. `Date` or `number`) of paths to return. This is also used by [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms).

<div class="button-row">
	[Playground](btn::https://www.typescriptlang.org/play?module=1#code/PTAEBUFEGV2goeAXAngBwKagDIHsDmAIgIZLGgC8oA3vKKAJYAmAXKAHYCuAtgEYYAnANx1Q3DAGcJxfBjYSkAhu3wj6TUnNAkkGNaE4TBAfja169Zmy59B++u2Lj5i5atEBffWXwSXSlQBtAF0RL0QAY1x2BVAAGwIdYjY8IlJyKnNGVlAARgAaUXEpGS0AIjLC9U1rDAB3bU0ACgBKKoMjATN4AEgrPMKex2dQMoAxAWJ2CIYJMs92nz9QQLLiXgiy4PgPRFRMHAJsDGIAN0lKUDHcAW4ABVIAC2OzyQAeVKSAPhEQCwA9YzIdBYVLQVwqF7nCSXa63B5IZ4naEfRLpfKgBQBfA-eB-eiA4EHVIAOR4-AEUIuVDh9yeVIkqLSZAxNgpuPxoEJ+1BaN0DNhNzpiIZTKSGJ0GA5YAJQPgRiQADViHFOBgmglmcQMWUNLpKhx6o1dE0ygAmAAMZoAzABaK323JlFotEQK5Wq9Wa8WjJaBC3BA1lXQKZ0iKIxXBxDAAOk1Gr5xFd8owSpVaoTWp1eowQctZoALI7HWHEH8AMIAeUIkDLYHAjymAGsYUhcKBHkgkGg-CAFMQIk3cOcBAAzBJ1GNRbjAYjAADs84LAFZctaAGzzhcWgAcAE4C0SsABJCQAQXYKDe4C+l14uCjJ3YoAwAA9dOwmDCmuAX++MJ+MLsBgI6gMYoCKGqoBsKOKpGC0YEQQIUEwXBeiIG+aA3EgEEgqAZ5xHEADSGAoIyN6XL+b4fl+ECIU2pG4KOdG1COIhHqAdwMIO4AgteGJEX+NEwgRxGkeRXy3lQVH-oBNArE2jDPkRwRsMoo6CKAx66NwoAeIh2kYLprF2HWECNuwLYQe2nbdr2wBMCBMZtsAqozFMGzAJw7AMNEto8ra4gCPgbi2so-kghIERKGgSC2nuKrwJh2G4QcACygiyAAqj50TXlJNC9IEgnKPhhEkWR+WqZx3FNrxmD8aARG4uEeIAFQvhIcTKHFTCzOs0agAAAjyUUxXFkjdewSDAOwuC2ph3UzHFUwoKAbXAElr5YQIOGjt5ERIL5z4SGg3VIAijxNGgTz+G4CG0D0AippwAjPjdiK9D0zm4OC2KtF9ManedTTAIEgQADrBDGwQANTAC0gOjgwcS6AITTXQhFC3mgya7FtO17QdR3RGImUYJd123aATRYm4oAAD4cOSmlMxIKB8FGLQhA9vTPUgr3vU8MbPUwnAROqTQDhEd0qKy1FY7ej09BGsQMWtVB-W4TTAe+yY9H0zFNDyTGGu+lAUFQZRsoIZSM0zwD-BDTCwwAJMAzmSEgTTqy6oDS6AsNUAABoErvUOrHjBMHIgGxgcRGIwRsAITSwhAdB6A6uxz08eJxnIcxuHkcx4gBv84L-sRBEsceDqpb4zyoAAEKcCjSDHuwla8AAVhgh0wlQkqM6A0Cpm83lNnNdTsLeTNjCj6HtW1dAddgsxIDCKpxKAH2PDCpVTKAuC9-3OHEDCdMqFXEtSDcEgxqvm3JbtqVYLSl3XkJAG0SffeHRieqWAqCrQKlffAoAABkdFqI-y3peXo4EtYqE-uADE1BQDI1RoINgaxCJlCEMfXuZ40CYE-CZYQu9qYVEITyNgQC9JfF6BQ9iwA2or3WjgDeVDEQH2fEfP+Z9-aXwhBA6WkgJD3wxLwTgOFohxDWnUBgiIOB+UEQPYRN8JEMF4INNAAhcCYF2gwSQj9OHQAYNwFGxABDWQgo8LA0ZXh8P9qoxySEMAYAxAwZiKBcCcHiA+RSpB7FYHUefLeHisBYnFgLZ6ZiNoExSk3D+9JkTvBksJIh-8kCALwiAy8YDRFQJgbJWiq1EGj1Eag9BmD244NGE46EBDskkLITkYCbEeGPFwS0uhEA8IeCYT0FhZZ2Gry4bEPeLiBGn0Opo8BWi74CAkNI2Rx92AKNAEolRc12C2nCVvLe1dtG6KwPowxggjqmImQRSRSkIiqkcq2BxoAAD6ggDErLqfHJgmCbjZLPvAv5NjJhkQSc-bayS8KpJFOkiQAB1ZRjxIACC+eRb+clwl5IOAUlARTsQlMyXA-2CCehIOqU8RqGCsFo1wU0yQLS-5tJ-rgj5aL74tL3r02hIJ6GDOGaM5eEz16xG3v7NFxAyJKVJYC+ZF9MTFPEcsh+T8kmvxSUKS6Z5JWVWJViuZuSBm4tJfiy4izoH6vKWSil2IanyVpQ0tYuq5iEOZaQ1lhounctGH0vlxqsBDOYV60yHFyzRAiKQN4l1MW0XARiEk1FY0iOxAVYO4dLoeAzU8ZNvrEIVGgqMGMZQs3UETe+DwpcOLIPwJdSssVjqD0Kj0R1XRRigqlXMEeZQGVdqZnguIBDejuvabLCBTNOmmR6D68Bsd+mrTCOxJux5RxvHrSTGIuaa11obdEVZnFRa5vVqbddjaMTQE4L3QBDj2AYkgAnLxoAPRqgKqevdgQ7ii2CFuy9PdKlvpiKsHkWxc2ToEF9cCDYAJfTYM+rAsC5IAYkEBkEWwvrkvMtBg2IyQ3gZw-eowS68Lbqpb0K1MJsW9CQ1uyliJqOZC+q23B28h0GxHZ6sDOcfU0K+v0zjvRdgFXIy3NuqNO7dxyRISpK6127piDqVtQZe1237SxjESHVh7y2PLEcgDBWlKyU0dSmksrc22AbIE2GehMxk0hnU7HPwGnjaAcN0wo0abKFp4I6m5PIbKA5pgWwvg6cEHp9D1mtKrrs6MRTOoO1kRU+2-BPmN1+a8yFgQYWrNMyaCSaIZJCIDQwG8LKt4EO-0NeFizVS7Wkas1ZvL7ACtxCKyV4LVXsPK3qwbJjoAPOKdCB17DAW2AeYC1sHO3Xp3U3TdQDzXmPBh2oDbAQUdS5TYNv0jzwHBsbd2FN4Z9W2C2d8wp+pAglPwsSwOg0s35tPC2It8OK21sZb04jA23QrPFRlZAd8kxDpvFEhVCSGJwFfGqo15rrXwDFWCGVspFHKv1cs91mzUXTujHG2D0RGJXORqQLJ1LmmHveb6751Y434dvYgHDw79WmZQ84IVs5146e5qM+wDStjTMhA66jtHkWidnpi+doM8W+1JcHXjiN7mKeedJwJYLuHAF06GxF3L+XmctdZ6V3Nk9p7sD5xt6rJ3UtnewRduLLrrtqZc7Lwn93ETadALNoiT3lss1W9HZXYHVcqXp1NtgTOWfRja7m8J6vsPgVPBeK8sOA+5sghgKP0f7ducd-L9Lrvw7u6Wy9n3qfPtC+i2UWLUuDT47l8ThXzuydu49wX4OvuQKhdAKVovx2Mfm9F5by7zjbfJfTwT4X77a+PBdw3-PXu1st90+3r4H2ps5ZDzrsPevytI5yan21bhP5F56Kv1rpXBgm4Nl1s-vX+ti922ftjxCPXkPJzXqnk2z8+qr5nmv2ep-PZnz7t-E3LbeXHbQAqbfbM-QPbrChJfKzY7c8S8NnRPTfJCNUIbcCT-UfQDcfF3ZqIbFgKPdHN4IvOzIvMvMXU-E3G7SgjbTAp3CfMnZqGgqbA3XAGeXNBPb9DAh3LAtLRXJqW8ChZg7rTgqPegKA7LGrPfOrM-I-VnTg9rO-C-DbK-eXAbMA7rEbZ-RtSnB-dpCbA-D-Hg+g3A3EO-HoYAmvUAovCAqbcQqrLvXgi3NGfvZpbtO3OgrPfgpglXWnAPSbRbP7RQAcQnYHcSfKHHVNQbdVHCTVeEJ4IBRqO4XNcHS4ZIlA49ZicASpWHO4czNgdIxHZmWwPDDDbI4vQorJYOIuagYzWxAAJS9krXQ3AlhUeESLkLDxvAxEaIUHpwKNzVmwL3DjqNAF6KQGaKs3Ak6OKwohQM5253bzMyq1aK1QSL4iyh6K9igLMCUlOBVGYDeT3lyAKMISAXoT0nCwGJQNm1GLzxGK500nGMmKmKaiPUYmYhmPyn5yuDWMRA6K11D1mK+Dhy2L6I6zYDaMSLQTGO2IcM4kGIeMWPdxqNGOeODh+MEgyI+NAC+JvHQN+PiP+L4jxJBJUjBKQAkJw1JI51GN53Mym1WKJPaI2IpKpJwwwWUH2O6iYCOKeDNFOIDQuNsOw2uKKNDiRM0nd2hklIaKaIxMZLeJQJW3V0g1pMeJ52WJNyZOFBZIak2NhPBJN12K5ION5L3mtEFPOLohFLgIRJuL-xKJeMVJpPmLpK1O1Pb1TxNPYG5MOL3gLCtP9V-FtLtMqJJUyNxMBLX2BJ3yjKa21xhxBLyO9PtPFMdIpGdI22mOjKTPVMWPpIP3AiygPx9L9PNKeGXCDMwGFM73klNJ5L5MRHXGrK0BDPwLTKyQqFVIgHVzFKyTCL1XZIwwymCgwBymOnyg-QZKD3rN9LNKbMeHnFbOFPYhfiJmmA3UxFTDg2IJ6GE0aKiAECYDeEWQnS9wxFYJnkUPDLkjaNFG6N6EVFzShL4hhLuCYS+CaGHV7noUGB9TuEGG5LVFg3gF5hVj3RwjQFFRwioD3kBmBmUVBnBihhhnhiXxjFbQxgYEVjflNgYFAGTktlGG8kcmRmAkCygWgQIqIqtmdEBm4GIDQGwtwqMwkBJGIBJFyy9yMz9nAgIuDx4pwpdFjlVhwhawUAqkuGgo3hjCwmYv1h8RpgkqQCkstioFIowHIowCYAQkRAMQaGAgaFRS+VNE7nLO6WLX1jEt3lwB6k0jgpgpFh0vFklmlh4GZ1IBuDYEPJuBPLPOKIpEvMskN2VwiFememmjgzHRHhW1wuViUqlmrg8pazbAEECHCrRQAjTE9G-XUoME-C0uUB0vTmSu4E8rSoyoiuyrgzypoHCHLhejehvhSq8vSsysipyrVG-QVV8uPNPOKXPJKOCqnjYNnlrgxD-kUpTg1AvlUtIhlSwnsoED9n0rYMNGMo5XRjKHMrNMsvMlmEYBhG6gYi2TFiwDbFcSsSkHpniyUkclfCstjkSqWumkEECBUoqm-UgWgRNmYlerRg+rmq+sIuIr+tAGAowCXzWsMqNBMpuCaGDl2p5IhvTAupBBjFAD+0wEOh0tAHDnBoBves+tImCH0hkRwnwFwBwgJpBFNkho8BjGDn1iJvSpJpQDqshtjgrmar-jCHgCAA)
  [Source](btn::https://github.com/ciscoheat/sveltekit-superforms/blob/main/src/lib/stringPath.ts)
</div>

```ts
// Thanks to https://stackoverflow.com/a/77451367/70894
type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;

export type AllKeys<T> = T extends T ? keyof T : never;

type PickType<T, K extends AllKeys<T>> = T extends { [k in K]: infer Item } ? Item : never;

// Thanks to https://dev.to/lucianbc/union-type-merging-in-typescript-9al
export type MergeUnion<T> = {
	[K in AllKeys<T>]: PickType<T, K>;
};

/* eslint-disable @typescript-eslint/no-explicit-any */
export function splitPath(path: string) {
	return path
		.toString()
		.split(/[[\].]+/)
		.filter((p) => p);
}

export function mergePath(path: (string | number | symbol)[]) {
	return path.reduce((acc: string, next) => {
		const key = String(next);
		if (typeof next === "number" || /^\d+$/.test(key)) acc += `[${key}]`;
		else if (!acc) acc += key;
		else acc += `.${key}`;

		return acc;
	}, "");
}

type BuiltInObjects = Date | Set<unknown> | File;

/**
 * Lists all paths in an object as string accessors.
 */
export type FormPath<T extends object, Type = any> = string & T extends any
	? StringPath<T, { filter: "all"; objAppend: never; path: ""; type: Type }>
	: never;

/**
 * List paths in an object as string accessors, but only with non-objects as accessible properties.
 * Similar to the leaves in a node tree, if you look at the object as a tree structure.
 */
export type FormPathLeaves<T extends object, Type = any> = string & T extends any
	? StringPath<T, { filter: "leaves"; objAppend: never; path: ""; type: Type }>
	: never;

/**
 * List paths in an object as string accessors, but only with non-objects as accessible properties.
 * Also includes the _errors field for objects and arrays.
 */
export type FormPathLeavesWithErrors<T extends object, Type = any> = string & T extends any
	? StringPath<T, { filter: "leaves"; objAppend: "_errors"; path: ""; type: Type }>
	: never;

/**
 * List all arrays in an object as string accessors.
 */
export type FormPathArrays<T extends object, Type = any> = string & T extends any
	? StringPath<T, { filter: "arrays"; objAppend: never; path: ""; type: Type }>
	: never;

type Concat<Path extends string, Next extends string> = `${Path}${Path extends "" ? "" : "."}${Next}`;

type StringPathOptions = {
	filter: "arrays" | "leaves" | "all";
	objAppend: string | never;
	path: string;
	type: any;
};

type If<Options extends StringPathOptions, Pred extends keyof Options, Subj, Then, Else, Value> = Options[Pred] extends Subj
	? Options["type"] extends never
		? Then
		: Value extends Options["type"]
			? Then
			: never
	: Else;

type StringPath<
	T extends object,
	Options extends StringPathOptions = {
		filter: "all";
		objAppend: never;
		path: "";
		type: never;
	}
> = T extends BuiltInObjects
	? If<Options, "filter", "leaves" | "all", Options["path"], never, T>
	: T extends (infer U)[]
		?
				| If<Options, "objAppend", string, Concat<Options["path"], Options["objAppend"]>, never, T>
				| If<Options, "filter", "arrays" | "all", Options["path"], never, T>
				| (NonNullable<U> extends object
						? StringPath<
								NonNullable<U>,
								{
									filter: Options["filter"];
									objAppend: Options["objAppend"];
									path: `${Options["path"]}[${number}]`;
									type: Options["type"];
								}
							>
						: If<Options, "filter", "leaves" | "all", `${Options["path"]}[${number}]`, never, T>)
		: {
				[K in Extract<AllKeys<T>, string>]: NonNullable<T[K]> extends object
					?
							| If<Options, "objAppend", string, Concat<Options["path"], Options["objAppend"]>, never, T[K]>
							| NonNullable<T[K]> extends (infer U)[]
						?
								| If<Options, "filter", "arrays" | "all", Concat<Options["path"], K>, never, T[K]>
								| (NonNullable<U> extends unknown[]
										? If<Options, "filter", "arrays" | "all", Concat<Options["path"], `${K}[${number}]`>, never, T[K]>
										: NonNullable<U> extends object
											? IsAny<T[K]> extends true
												? Concat<Options["path"], `${K}[${number}]`>
												: If<Options, "filter", "all", Concat<Options["path"], `${K}[${number}]`>, never, U>
											: If<Options, "filter", "leaves" | "all", Concat<Options["path"], `${K}[${number}]`>, never, U>)
								| (NonNullable<U> extends object
										? StringPath<
												NonNullable<U>,
												{
													filter: Options["filter"];
													objAppend: Options["objAppend"];
													path: Concat<Options["path"], `${K}[${number}]`>;
													type: Options["type"];
												}
											>
										: never)
						: IsAny<T[K]> extends true
							? Concat<Options["path"], K>
							:
									| If<
											Options,
											"filter",
											"all",
											Concat<Options["path"], K>,
											unknown extends T[K] ? Concat<Options["path"], K> : never,
											T[K]
									  >
									| StringPath<
											NonNullable<T[K]>,
											{
												filter: Options["filter"];
												objAppend: Options["objAppend"];
												path: Concat<Options["path"], K>;
												type: Options["type"];
											}
									  >
					: If<Options, "filter", "leaves" | "all", Concat<Options["path"], K>, never, T[K]>;
			}[Extract<AllKeys<T>, string>];

export type FormPathType<T, P extends string> = P extends keyof T
	? T[P]
	: P extends number
		? T
		: P extends `.${infer Rest}`
			? FormPathType<NonNullable<T>, Rest>
			: P extends `${number}]${infer Rest}`
				? NonNullable<T> extends (infer U)[]
					? FormPathType<U, Rest>
					: { invalid_path1: P; Type: T }
				: P extends `${infer K}[${infer Rest}`
					? K extends keyof NonNullable<T>
						? FormPathType<NonNullable<T>[K], Rest>
						: FormPathType<T, Rest>
					: P extends `${infer K}.${infer Rest}`
						? K extends keyof NonNullable<T>
							? FormPathType<NonNullable<T>[K], Rest>
							: NonNullable<T> extends (infer U)[]
								? FormPathType<U, Rest>
								: { invalid_path2: P; Type: T }
						: P extends `[${infer K}].${infer Rest}`
							? K extends number
								? T extends (infer U)[]
									? FormPathType<U, Rest>
									: { invalid_path3: P; Type: T }
								: P extends `${number}`
									? NonNullable<T> extends (infer U)[]
										? U
										: { invalid_path4: P; Type: T }
									: P extends keyof NonNullable<T>
										? NonNullable<T>[P]
										: P extends `${number}`
											? NonNullable<T> extends (infer U)[]
												? U
												: { invalid_path5: P; Type: T }
											: { invalid_path6: P; Type: T }
							: P extends ""
								? T
								: P extends AllKeys<T>
									? MergeUnion<T>[P]
									: { invalid_path7: P; Type: T };
```

#### Example

Given the following object type, we can see the different types of paths that can be generated.

```ts
type LogData = {
  id: number;
  message: string;
  date: Date;
  user: {
    id: number;
    name: string;
  };
  tags: string[];
}

type LogLeaves = FormPathLeaves<LogData>;
//   ^? "id" | "message" | "date" | "user.id" | "user.name" | `tags[${number}]`
type LogStringLeaves = FormPathLeaves<LogData, string>;
//   ^? "message" | "user.name" | `tags[${number}]`
type LogNumberLeaves = FormPathLeaves<LogData, number>;
//   ^? "id" | "user.id"
type LogDateLeaves = FormPathLeaves<LogData, Date>;
//   ^? "date"
```

### Set Nested Value

Below is a `setValue` function which takes an object, a path, and a value. It is not from the Superforms library, but rather showcases how some of the above types can be used.

The path is a string of dot-separated keys. The function should set the value at the given path. The path parameter will have autocomplete and the value parameter will be required to be of the same type as the property at that path. See the playground for examples. This function works very similarly to [lodash.set](https://lodash.com/docs/4.17.15#set), but with stronger type safety.

```ts
export function setValue<T extends Record<string | number, unknown>, P extends FormPathLeaves<T>, V extends FormPathType<T, P>>(
	obj: T,
	path: P,
	value: V
) {
	// Split the path into an array of keys and convert any numeric strings to numbers.
	const pList = path
		.split(/[[\].]+/)
		.filter((i) => typeof i !== "undefined" && i !== "")
		.map((i) => (isNaN(Number(i)) ? i : Number(i)));
		
	// Remove the last key from the array and store it in a variable.
	const lastKey = pList.pop();
	if (!lastKey) throw new Error("Invalid path.");

	// Create a pointer object that traverses the nested properties of the `obj` object based on the `path` provided.
	// If a property does not exist, it will be created as an empty object.
	const pointer = pList.reduce((accumulator: Record<string | number, unknown>, currentValue: string | number) => {
		if (accumulator[currentValue] === undefined) accumulator[currentValue] = {};
		return accumulator[currentValue] as Record<string | number, unknown>;
	}, obj);

	if (!(lastKey in pointer)) throw new Error("Invalid path. This is likely due to a missing array index.");
	if (pointer[lastKey] && typeof pointer[lastKey] !== typeof value)
		throw new Error(`Invalid value type. Expected ${typeof pointer[lastKey]} but got ${typeof value}.`);

	// Set the value of the last key in the pointer object.
	pointer[lastKey] = value;
	return obj;
}
```

#### Example

Using the object from the previous example, we can set the value of the `date` property to a `Date` object, and the value of the `tags[0]` property to a string. We can also see that trying to set the `date` property to a string will result in a type error.

```ts
setValue(logData, "date", new Date("2023-02-01"));
setValue(logData, "tags[0]", "test");
// [!code word:"2024-01-01":1]
setValue(logData, "date", "2024-01-01"); // expected Date, received string // [!code error]
```