---
title: TypeScript Helpers from Superforms
description: Utility types from the Superforms library and how to use them.
date: 2024-03-12T22:23:39.398Z
updated: 2024-04-28T03:48:57.500Z
image: $/assets/images/superforms.webp
tags:
  - TypeScript
---
import Collapsible from "$/components/markdown/collapsible.astro";

## Table of Contents

## Superforms Types

<div class="alert-box oklch warning">
The code in this post was written mostly by Andreas Söderlund, the creator of [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms), and is useable under the MIT license which must be included with all copies.

<Collapsible title="MIT License">
Copyright (c) 2023 Andreas Söderlund

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</Collapsible>
</div>

### SuperStruct

The `SuperStruct` type is a utility type that transforms the properties of an object to an alternative provided type. It is used by [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms) to transform the properties of a form schema to a type used for validation errors.

<div class="button-row">
	[Playground](btn::https://www.typescriptlang.org/play?#code/PTAEBUFEGV2goeBLAtgBwPYCcAuoDeokAjgK4CGANgDREAeaApgMZ4C+oAZlhiqAEQABHBhxUAtDgCeTAM7MsSNDmAALRpSZZZ-ANyJpTUABkMAcwAi5MaAC8BeKFBIAJgC5QAO1IoARoyx9JxRGWVlyM0YPWRxFTzMg0BdrKNAYuITHUFJZAI98LKdXD28-AMSnT3IQ6NikeMS2RLEzWVqMgG0AXX02AxlGE3NILB5tO1BoUi1oWNJWAB5TS2tyWnT6s26APn0QJ1AAPQB+fqNwULx7SAYWHAWSCkol4dHsWQ7+V34u9br47qgAA+2U8LkYnHqjBc2128H2ThOiGYGE8MVAATGbSGZhGWImBScOTyDgOzncoE+eOwoBCYQijB+WT6TUQ+wAwgB5CyQRCMBjYPCGQYAQUolAA0owpLIFuBthNwBi6DhGGDZBBQMdQABraUYTiakqMABu5TZYFClHqOHELiQ4V8lEY4k8-Nt1rdoGEA3kimU4itNuAngwgYY1uYSFt5E8UngwtAAAUkMwdeABnLaBLlar1aAxZLpbL5Qr7Er3WqXBrCB0dc5PKAJV0PLGpKAONrwB1m6BjWbAhaIKpYzqNSJQKocDg0G0QOCTQA6ETASjzJCx3zMYCkTxIVGSAbiEJYMybcT1Q9yBRKW0ATio8H5mFwoETAFkApEAKp71FyssHAASB7BsC3FKUZQAltk1TdNM3AbM4VZJ8BVfRMphmOZWBFUZyCkOVcyrDUACUWGwFwFg2eJaF3HVQwAd08bZaCsMRaFwrB8LY8gJjoxjmIJeAgP2INPFte1HWdV13XET1Bh9a9-VtMSVFDcM0EjaNxDbYSOiTHgtGkMDC0gktti6Y4PA6cAuiI-MOjbLphKA7UADlUTc0hxXIJ1GDlfTDICaQugVSt8zIlEsEo6izFozx6IwJjthc1zJmmAJZiweYcE4-CFk-U9GF-fdPAWDzPC8ny-ICgyMCMqRQpY0AeI4vCpB4lKgO6jwKqqyhfOdWqgtwRqwpVYjQAACnqTgAgLABKbpUrSvKOtWUAADIVu6yKKIWHbutKfwsGBNJ-jiw6gL67yBpqkVxrzatQD26KqIu+LEuSq60swzLsNy9qCq-Yq-zKm7qqGh7mtagt2s6n6PB4w6uu6oCkdWFz+3NFDn0FN8BnSrDssWCsJoi8i3tiz6BJh1ZAKTchcA3Z4ChEy1ZE9CSHUGl03RVOSoW9YU-VvQNOeDdTny0mM4z0uqGpMiDi2g6zbPs57HLjZzuvczzbt54b6uCsaNdIymYo+0EvuY1LtT+rAspy4GipK-8IbuobuwVk2mtY+nUt6-XIf872RpCx7Jpmzw5tOkUlp1tG9cqg37sjimostjIaaS220d1on-pJ+5Cp-MHyuDz3-Oh-2xFRtGMbEFbG-ILGvFNHHdiAA)
  [Source](btn::https://github.com/ciscoheat/sveltekit-superforms/blob/main/src/lib/superStruct.ts)
</div>

```ts
export type AllKeys<T> = T extends T ? keyof T : never;

type PickType<T, K extends AllKeys<T>> = T extends { [k in K]: infer Item } ? Item : never;

// Thanks to https://dev.to/lucianbc/union-type-merging-in-typescript-9al
export type MergeUnion<T> = {
	[K in AllKeys<T>]: PickType<T, K>;
};

export type SuperStructArray<T extends Record<string, unknown>, Data, ArrayData = unknown> = {
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	[Property in AllKeys<T>]?: [T] extends [any]
		? NonNullable<T[Property]> extends Record<string, unknown>
			? SuperStructArray<MergeUnion<NonNullable<T[Property]>>, Data, ArrayData>
			: NonNullable<T[Property]> extends (infer A)[]
				? ArrayData &
						Record<
							number | string,
							NonNullable<A> extends Record<string, unknown>
								? SuperStructArray<MergeUnion<NonNullable<A>>, Data, ArrayData>
								: Data
						>
				: Data
		: never;
};

export type SuperStruct<T extends Record<string, unknown>, Data> = Partial<{
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	[Property in AllKeys<T>]: [T] extends [any]
		? NonNullable<T[Property]> extends Record<string, unknown>
			? SuperStruct<MergeUnion<NonNullable<T[Property]>>, Data>
			: NonNullable<T[Property]> extends (infer A)[]
				? NonNullable<A> extends Record<string, unknown>
					? SuperStruct<MergeUnion<NonNullable<A>>, Data>
					: Data
				: Data
		: never;
}>;
```

#### Example

```ts
type LogData = {
  id: number;
  message: string;
  date: string;
  user: {
    id: number;
    name: string;
  };
  tags: string[];
}

type LogErrors = SuperStruct<LogData, string[]>;

// [!code word:string\[\]:9]
// Converts each property to string[] | undefined
// LogErrors["id"] => string[] | undefined

// Converts objects into a partial with each property as string[] | undefined
// LogErrors["user"] => Partial<{ id: string[], name: string[] }> | undefined
// Exclude<LogErrors["user"], undefined>["id"] => string[] | undefined

// Converts the tags array itself to string[] | undefined
// LogErrors["tags"] => string[] | undefined

type LogErrors = SuperStructArray<LogData, string[]>;

// [!code word:string\[\]:9]
// Converts each property to string[] | undefined
// LogErrors["id"] => string[] | undefined

// Converts objects into an object with the same SuperStructArray type
// LogErrors["user"] => SuperStructArray<LogData["user"], string[]> | undefined
// Exclude<LogErrors["user"], undefined>["id"] => string[] | undefined

// Converts each value in the tags array to a string[] type
// LogErrors["tags"] => Record<number, string[]> | undefined
```

### FormPathLeaves

The `FormPathLeaves` type is a utility type that takes an object type and returns a union of all the leaf paths of the object. It has an optional second parameter to specify the type (ex. `Date` or `number`) of paths to return. This is also used by [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms).

<div class="button-row">
	[Playground](btn::https://www.typescriptlang.org/play/?#code/PTAEBUFEGV2goeAXAngBwKagDIHsDmAIgIZLGgC8oA3vKKAJYAmAXKAHYCuAtgEYYAnANx1Q3DAGcJxfBjYSkAhu3wj6TUnNAkkGNaE4TBAfja169Zmy59B++u2Lj5i5atEBffWXwSXSlQBtAF0RL0QAY1x2BVAAGwIdYjY8IlJyKnNGVlAARgAaUXEpGS0AIjLC9U1rDAB3bU0ACgBKKoMjATN4AEgrPMKex2dQMoAxAWJ2CIYJMs92nz9QQLLiXgiy4PgPRFRMHAJsDGIAN0lKUDHcAW4ABVIAC2OzyQAeVKSAPhEQCwA9YzIdBYVLQVwqF7nCSXa63B5IZ4naEfRLpfKgBQBfA-eB-eiA4EHVIAOR4-AEUIuVDh9yeVIkqLSZAxNgpuPxoEJ+1BaN0DNhNzpiIZTKSGJ0GA5YAJQPgRiQADViHFOBgmglmcQMWUNLpKhx6o1dE0ygAmAAMZoAzABaK323JlFotEQK5Wq9Wa8WjJaBC3BA1lXQKZ0iKIxXBxDAAOk1Gr5xFd8owSpVaoTWp1eowQctZoALI7HWHItFYspTirmABxVOXWRITM+srMIPgSRIUsR2JVuK1+tURvN9GjYrSWTtzvd8tR2PxvsDpDJvFgADCAHlCJBEH9wI8pgBrGFIXCgR5IJBoPwgBTECKH3DnAQAMwSdRjUW4wGIwAA7H+BYAKy5NaABsf7-haAAcACcBZElgACSEgAILsCgbzgF8ly8Lgc5TKAGAAB66OwTAwk04BEaRGDkTC7AYM+oDGKAihqqAbAviqRgtCxbECBxXE8XoiAkWgNxIGxIKgKhcRxAA0hgKCMthlzUSRZEURA-GHspuAvjptTPiIiGgHcDAPuAIJYRiCk0VpMJyYpymqV8OFUBptH0TQKyHow7CgApwRsMoL6CKASG6NwoAePxUUYDFxl2LuYD7keJ5nheV43sATBMTGp7AKqMxTBswCcOwDDRLaPK2uIAj4G4trKLVIISBEShoEgtqwSq8DiZJ0kHAAsoIsgAKpVdEWEeTQvSBPZyiyfJSkqbNIXmZZh7WZgtlBbi4R4gAVEREj9uwPVMLM6zRqAAACPIdV1PWSBdSDAOwuC2uJ-YzD1UwoKAx3AANxESQIUkvpVERINVgUSGg-ZIAijxNGgTz+G4fG0D0AippwAiBRjiK9D0hW4OC2KtGTMaI8jTTAIEgQADrBDGwQANTAC0tMvgwcS6AITTo3xFA4Wgya7GDENQzDcPRGI40YKj6OY6ATRYm4oAAD4cOSEV6xIKB8FGLQhDjvT40ghPE08Mb40wnAROqTT3hEWMqKymlizhuM9D2Ul6UDVBU24TSMaRyY9H0hlNDyBmGqRlAUFQZRsoIZS63rwD-CzTCcwAJMAhWdk0wcuqA7ugJzVAAAaBIX1DBx4wR1yIMcYHERiMHHACE7t8dXtegMHHc9F3PfD-XMZNy37eIDH1u21XEQRB3Hg6qW0s8qAABCnAC0gSHsBuvAAFYYLDMJUJKuugNAqZvJVh5fXU7A4XrYwC6JJ3HXQp1sCzCQDCFUcRQAk0eDCZahFcAXyvlJYgMItYqFXi7KQNwJAxgAaDQakNhpYFpKjLCDk6LaTgZfWGGJdpYCoIDOaKD8CgAAGS9DDioYh4AMTUFAPzQWgg2AAHIwGCKEKAChqE0CYHIslYQED1aCNEQQtgNDYq4j-gAnAwD5GImgYFWB8DYZV2QRCJh7tJASEwRiXgnApLRDiEDOoDBEQcBqhQhBoDQFrwsQwXgd00ACFwJgSGDBJDYOBg-Bg3ABbEAEGxM8iIsDRleHoqurj8oCQwBgDEDBDIoFwJweI+F-KkDYo8LA7ijFILSYoLJmJ2Kw0JrGHBMshq7yIfSZE7wvKOXEYYpA1CZJ0Iwgw0xLC2GmM4dw3hR8BGgEEck6ESiJFSLIbIsRkChFKJ5ComSHh1HAGOv-CJQDYiQNSQYyhiCTHYjQRYqxoAbF2PYA40ATiXFfXYLaSpIDjF3KkL4-xgTglwzCZouSliAoRFVPlE85TQAAH1BCBIEDCfmXcmC8JuH0q5oDyJVwEJMFS4SQatPwe0oUqMGQAHVnGPEgISzBJDNJkJhD8wZBxhkoFGbc1hPR2H4Cmb5PhQshGLMkMsi+kjpE5EEUixlqKlGbPmdskEuyDj7NMoc45gDtFgIJUSi5gUfl-MYf8yxqKSW4PBm0mSHTESoUJcQdaPTWU4oQRy2hVcRmXDNXygVQqeEirmcIp1KlJXn2lWsw0JkdGPC2WInZEA9nqN3muaIERSBvFRqQnyjCMQkk0rm7SjC5p1ybqjDwFanjFphBUfi9a2BlBjGUKt1BC2kQ8AvMyAangbm6vDG+80ejBq6KMWJhqs56zKOKuY981jyTKB3FZMrPZML1oxEyvRlWMI7kmwGYRTK7yQi+N4-aFYxFrQ-SZfaB3lgxHcR2V7g6J3PYOjE0BOAX2oeU9gGJIDd2yaAD0ao5pvvLIER9GAmDBCvZ+i+vRWLgZiKsHkWwr2bsEGTVi+46JkzYCBrALKfLIYkKhkEWwyY9Bw7+qjsjehsAA0YI9Mle2IjeL0V1Pl2W9FI3Bm9iI+OZDJqOptYCl1kxXdGzDwgybKoqOPJNMmN7wDmlx7SB8j4nzPrixDkVT2kZ1KOoMs6p3jsXRiUjqxIFbG9s+ahXwGM6WI9pJoYUIoTXNtsGOQIY4xz1ies9d6Yg6ik+RA0+bQDpumFmqzZQbPBEs8FsjZQwtMC2F8OzggHNUZ6AFgzyWjOzIEEGCdzq53TvE0li9KWEtZYEDlvzeWNYkmiGSeSt0MBvAmjhFzbL+m5Z89e7ExDBt+da+wdrcROvdcy2NmO-smt+dE6AOLxnQjzZjmltgcW0tbHHktmOyry3UDiwljwjdqAZwEK3Beh2-NJri2hjb92ei7Hu45w7bBAuGdGMZnUpn51VdACds7TwtgXabtd279WHO8xjt0Jri0AqgEgKRSYsM3jOTWm5DEpbNoTamzN8Ai1gi9e8uQgbS3fOHfy0FmroWpWrPC3j0xGJouZqQPTwd1nweJdW8l1Ye2yew4gKTz7tPQCE84B1vxXWSfBXJ70tz7BwpxM8yEMbNPJc-cK394rpWw0VfM3EA0HPYuC-i3zuymWY3ZbF4rzbesmjS9l9GWbV6X5v3YJr17Q3dcM-1-wkrOoysqTMwu037OM0W5q7zxEtmQdNwUpDq7Bsbtt1tzJ6h4vNsI6l21mX025ce76+62Gef-doQwlhcXV72IYEr0N83XOwcJ-5ydlPl3oeZ6bz0b7BXA9lH+ybs3MfW+W7q0n6gXeofp9u1npi9uetN4H9z+9QehYma6cbyPY+YsT7j1b9vGJO+p573XRf9nQA9fh-d53rvi-u561en5lfWJsceBxv343C9u66z1oMD-j0Itj-itmtgbi9sAT0NtgLkfsLgdj-sqi3uvihsfo8Inmft3vPpnogX7o9pbs9ngfdu9j-hLq9rInfk1t9tXphArmTvXoJI3vdqxCgW3hgfzgpOQdQXnnTk3oZk3sPgbkAX7nviIa9mwZPtbgdOIfdl7rgO-FevQfxJIUflPlwZxHbg1k3vQXnvQNwUtnrJ-t-j-o-sTuLrIYdqAa9uAZbutsQYdrAbtkzjKvtn3sgePqgbVtIVwQ4UtgQUfkQU3qQfdvoYNmvr9kIcHtvikhHsDqoTzugYnlwaLvQbiH5hdmjooPeFztjq5LNKztiF8BtmSlJBSvCE8DQvtHcFeqWpcDUWXi+oZOAHpiTncN5mwA0RTgxOnthhAPhuZFenXLPNQO5nEgAEqdhdpUasT2qPBVFmEl7YQYiTEKDkGdFDFz62AZ5NxjGgCrFIDTFNasSLHu5qRl4q5q435eaDazGUqVE2QTQrGdgGFmABSLhMAIqQK5CdFiI0IqKxS5YbFl4nZ7Gz6jGq4RQHFHHHFBTPr6SGSnHy4GHUZXD3GIgLF-5P7Imk7PFrFjZsBzFVFcL7EvHhGDEgm7GQlxIp4jF7HQl1xa5wmNEIkF6TZF7E4omolEk2RImzS4mkn4n3ZsB8nnHdEax7Ea7eYsFokVEYmPF4lIBcn96+SVjVifGQJmi-HJqYAAkhF+bAnikNxUlXEp7swmlQlTGMkyn2Rl7XabY4ZXqXEeY3F+53FynzEKmClKl55vFqn9galPDWjan-E6T6nUEUlGlbEUgwkymilK5urOnq6uluk36V5+nsAfFfFPAFghlqphm+mRm9JNFslE5LHKlDbxmQbSkUFFluonbQ7Wk-4nFYmclOmSkpnNlpnQEZlZmQJAR5m6kFnAG9nqnZmIhgSDlaDUThn55dG9IVAOn9G1nzlup5EuoVmsRjSNQYBTTwz8ntGFk8L+nMDjmPB-hTl6mmR4JyzTAXqYipiEbf7qYwiTFRACBMBvBmobrp4YjyHvxzY9Crk+RzGijLG9CKhXo8l7Qkl3COZfBNC9AUIqKDDKp3CDB9hqgEbwCWwBzlhSRoCnJSRUCQK0z0zOKMzMxswczcx34xijoiwMC+wEKJwMCgB9ypyjCVT5T8yMTpYsLMKMDsWcUVB0XcDEBoCMXMVuYSAkjEAkgu7p5uaVysRsUilKVMUuimR4UxBSTTYKBrSXCEXAIxgSSSXRy5Iaz6VICGWpxUDcUYC8XQZ8SIiBINCMQNAMooqmgnwfFxotorg6VnK4DKBCxGVEUOzQbOyuzuw8Ay6kA3BsBvk3Cfnfn6zbF-nsCvwKEfwYgRCEz4yXSEZrr3zXbMX+yWVuxrxxXTangCCBD5WEp0RpieiwZ2UGDkSOXKDOVoI1UJX1WNWFUtVqhtU0DhBLwExEy9XcDxV1UNUFXNWEawbVLJUflfljI-kZUdXZUAUbwYgUKBWVV9wahII2XKQo4SShWCCVyuUKGGieUKo+WZnqn+UQCPCzCMAwj9h6SvJOxYCnhpLRIAqoJh4BT5TEQBUdyVWXWXSCCBDWVrSwbMKCUJyGQw1Czw2nWI3CVUCo2gCYUYB363XuVGheU3BNB1y+UvUE0EIxio7gwILQagBNx43o1w0I3KTBBxRPKgD4C4BSQs0giJwE0eAxh1zRzbohWw31Uc0oCjUE0dzLxTUUJhBiQ2r4LQx3nwy81PycZXqrWpUbXpUUiZU7W5W9DAXaSgU74FEQVQXomekwUPrwWIUwEXwoXbrqzoW9A8WEamDAY4XzT0CBwQJEVGVPBkVIwUVMyszsxcw8x8zFZSWUA4R41sUcVpwOVOX8XI1CUZ2jDOi0ziWSXKUp0SmyXyWKXbHKV8SqWaFkjV2aWBUh2y3hUmVmWtBQ1xyt3tVZ3dVMB8RK2BR918XaUh1s1xIkURWOzRUiyxUzW1WJWknvmG23KbUm3bXe626DWLXphaBpVlVl0VVxzz2zU3DzVNVFV71tWcUj09Wn2L0DULVX2tWXDUDjV4yTX6LVUL39UX1DVLV-IG3rVr3G327-kfx7U4qHX9wnUGXnXLQT2VzH0ay+172D1f2gBoOeh-KKjjyTxYBD0dU8X90qY9BWyYMT2Y3wNy1-LQXy7O1hBAA)
  [Source](btn::https://github.com/ciscoheat/sveltekit-superforms/blob/main/src/lib/stringPath.ts)
</div>

```ts
// Thanks to https://stackoverflow.com/a/77451367/70894
type IsAny<T> = boolean extends (T extends never ? true : false) ? true : false;

export type AllKeys<T> = T extends T ? keyof T : never;

type PickType<T, K extends AllKeys<T>> = T extends { [k in K]: infer Item } ? Item : never;

// Thanks to https://dev.to/lucianbc/union-type-merging-in-typescript-9al
export type MergeUnion<T> = {
	[K in AllKeys<T>]: PickType<T, K>;
};

/* eslint-disable @typescript-eslint/no-explicit-any */
export function splitPath(path: string) {
	return path
		.toString()
		.split(/[[\].]+/)
		.filter((p) => p);
}

export function mergePath(path: (string | number | symbol)[]) {
	return path.reduce((acc: string, next) => {
		const key = String(next);
		if (typeof next === "number" || /^\d+$/.test(key)) acc += `[${key}]`;
		else if (!acc) acc += key;
		else acc += `.${key}`;

		return acc;
	}, "");
}

type BuiltInObjects = Date | Set<unknown> | File;

/**
 * Lists all paths in an object as string accessors.
 */
export type FormPath<T extends object, Type = any> = string &
	StringPath<T, { filter: 'all'; objAppend: never; path: ''; type: Type }>;

/**
 * List paths in an object as string accessors, but only with non-objects as accessible properties.
 * Similar to the leaves in a node tree, if you look at the object as a tree structure.
 */
export type FormPathLeaves<T extends object, Type = any> = string &
	StringPath<T, { filter: 'leaves'; objAppend: never; path: ''; type: Type }>;

/**
 * List paths in an object as string accessors, but only with non-objects as accessible properties.
 * Also includes the _errors field for objects and arrays.
 */
export type FormPathLeavesWithErrors<T extends object, Type = any> = string &
	StringPath<T, { filter: 'leaves'; objAppend: '_errors'; path: ''; type: Type }>;

/**
 * List all arrays in an object as string accessors.
 */
export type FormPathArrays<T extends object, Type = any> = string &
	StringPath<T, { filter: 'arrays'; objAppend: never; path: ''; type: Type }>;

type Concat<Path extends string, Next extends string> = `${Path}${Path extends "" ? "" : "."}${Next}`;

type StringPathOptions = {
	filter: "arrays" | "leaves" | "all";
	objAppend: string | never;
	path: string;
	type: any;
};

type If<Options extends StringPathOptions, Pred extends keyof Options, Subj, Then, Else, Value> = Options[Pred] extends Subj
	? Options["type"] extends never
		? Then
		: Value extends Options["type"]
			? Then
			: never
	: Else;

type StringPath<
	T extends object,
	Options extends StringPathOptions = {
		filter: "all";
		objAppend: never;
		path: "";
		type: never;
	}
> = T extends BuiltInObjects
	? If<Options, "filter", "leaves" | "all", Options["path"], never, T>
	: T extends (infer U)[]
		?
				| If<Options, "objAppend", string, Concat<Options["path"], Options["objAppend"]>, never, T>
				| If<Options, "filter", "arrays" | "all", Options["path"], never, T>
				| (NonNullable<U> extends object
						? StringPath<
								NonNullable<U>,
								{
									filter: Options["filter"];
									objAppend: Options["objAppend"];
									path: `${Options["path"]}[${number}]`;
									type: Options["type"];
								}
							>
						: If<Options, "filter", "leaves" | "all", `${Options["path"]}[${number}]`, never, T>)
		: {
				[K in Extract<AllKeys<T>, string>]: NonNullable<T[K]> extends object
					?
							| If<Options, "objAppend", string, Concat<Options["path"], Options["objAppend"]>, never, T[K]>
							| NonNullable<T[K]> extends (infer U)[]
						?
								| If<Options, "filter", "arrays" | "all", Concat<Options["path"], K>, never, T[K]>
								| (NonNullable<U> extends unknown[]
										? If<Options, "filter", "arrays" | "all", Concat<Options["path"], `${K}[${number}]`>, never, T[K]>
										: NonNullable<U> extends object
											? IsAny<T[K]> extends true
												? Concat<Options["path"], `${K}[${number}]`>
												: If<Options, "filter", "all", Concat<Options["path"], `${K}[${number}]`>, never, U>
											: If<Options, "filter", "leaves" | "all", Concat<Options["path"], `${K}[${number}]`>, never, U>)
								| (NonNullable<U> extends object
										? StringPath<
												NonNullable<U>,
												{
													filter: Options["filter"];
													objAppend: Options["objAppend"];
													path: Concat<Options["path"], `${K}[${number}]`>;
													type: Options["type"];
												}
											>
										: never)
						: IsAny<T[K]> extends true
							? Concat<Options["path"], K>
							:
									| If<
											Options,
											"filter",
											"all",
											Concat<Options["path"], K>,
											unknown extends T[K] ? Concat<Options["path"], K> : never,
											T[K]
									  >
									| StringPath<
											NonNullable<T[K]>,
											{
												filter: Options["filter"];
												objAppend: Options["objAppend"];
												path: Concat<Options["path"], K>;
												type: Options["type"];
											}
									  >
					: If<Options, "filter", "leaves" | "all", Concat<Options["path"], K>, never, T[K]>;
			}[Extract<AllKeys<T>, string>];

export type FormPathType<T, P extends string> = P extends keyof T
	? T[P]
	: P extends number
		? T
		: P extends `.${infer Rest}`
			? FormPathType<NonNullable<T>, Rest>
			: P extends `${number}]${infer Rest}`
				? NonNullable<T> extends (infer U)[]
					? FormPathType<U, Rest>
					: { invalid_path1: P; Type: T }
				: P extends `${infer K}[${infer Rest}`
					? K extends keyof NonNullable<T>
						? FormPathType<NonNullable<T>[K], Rest>
						: FormPathType<T, Rest>
					: P extends `${infer K}.${infer Rest}`
						? K extends keyof NonNullable<T>
							? FormPathType<NonNullable<T>[K], Rest>
							: NonNullable<T> extends (infer U)[]
								? FormPathType<U, Rest>
								: { invalid_path2: P; Type: T }
						: P extends `[${infer K}].${infer Rest}`
							? K extends number
								? T extends (infer U)[]
									? FormPathType<U, Rest>
									: { invalid_path3: P; Type: T }
								: P extends `${number}`
									? NonNullable<T> extends (infer U)[]
										? U
										: { invalid_path4: P; Type: T }
									: P extends keyof NonNullable<T>
										? NonNullable<T>[P]
										: P extends `${number}`
											? NonNullable<T> extends (infer U)[]
												? U
												: { invalid_path5: P; Type: T }
											: { invalid_path6: P; Type: T }
							: P extends ""
								? T
								: P extends AllKeys<T>
									? MergeUnion<T>[P]
									: { invalid_path7: P; Type: T };
```

#### Example

Given the following object type, we can see the different types of paths that can be generated.

```ts
type LogData = {
  id: number;
  message: string;
  date: Date;
  user: {
    id: number;
    name: string;
  };
  tags: string[];
}

type LogLeaves = FormPathLeaves<LogData>;
//   ^? "id" | "message" | "date" | "user.id" | "user.name" | `tags[${number}]`
type LogStringLeaves = FormPathLeaves<LogData, string>;
//   ^? "message" | "user.name" | `tags[${number}]`
type LogNumberLeaves = FormPathLeaves<LogData, number>;
//   ^? "id" | "user.id"
type LogDateLeaves = FormPathLeaves<LogData, Date>;
//   ^? "date"
```

## Examples

These functions are used to get and set nested values in an object. They are not from the Superforms library, but rather showcases how some of the above types can be used. They work very similarly to [lodash.get](https://lodash.com/docs/4.17.15#get) and [lodash.set](https://lodash.com/docs/4.17.15#set), but with stronger type safety. See the [playground](#formpathleaves) for examples.

These example functions were wrtten by me.

### Get

In this `get` function, the path is a string of dot-separated keys, or brackets for numbers. The function should get the value at the given path. The path parameter will have autocomplete and the value parameter will be required to be of the same type as the property at that path.

```ts
export function get<
	T extends Record<string | number, unknown>,
	P extends FormPathLeaves<T>,
	V extends FormPathType<T, P>
>(obj: T, path: P, defValue?: V) {
	// Split the path into an array of keys and convert any numeric strings to numbers.
	const pList = path
		.split(/[[\].]+/)
		.filter((i) => typeof i !== "undefined" && i !== "")
		.map((i) => (isNaN(Number(i)) ? i : Number(i)));

	// Remove the last key from the array and store it in a variable.
	const lastKey = pList.pop();
	if (lastKey === undefined) return undefined;

	// Create a pointer object that traverses the nested properties of the `obj` object based on the `path` provided.
	// If a property does not exist, it will be created as an empty object.
	const pointer = pList.reduce((accumulator: Record<string | number, unknown>, currentValue: string | number) => {
		if (accumulator[currentValue] === undefined) accumulator[currentValue] = {};
		return accumulator[currentValue] as Record<string | number, unknown>;
	}, obj);

	// Get the value of the last key in the pointer object, or return the default value if it doesn't exist.
	if (!(lastKey in pointer)) return defValue
	return pointer[lastKey] as FormPathType<T, P>;
}
```

### Set

In this `set` function, the path is a string of dot-separated keys, or brackets for numbers. The function should set the value at the given path. The path parameter will have autocomplete and the value parameter will be required to be of the same type as the property at that path.

```ts
export function set<T extends Record<string | number, unknown>, P extends FormPathLeaves<T>, V extends FormPathType<T, P>>(
	obj: T,
	path: P,
	value: V
) {
	// Split the path into an array of keys and convert any numeric strings to numbers.
	const pList = path
		.split(/[[\].]+/)
		.filter((i) => typeof i !== "undefined" && i !== "")
		.map((i) => (isNaN(Number(i)) ? i : Number(i)));
		
	// Remove the last key from the array and store it in a variable.
	const lastKey = pList.pop();
	if (!lastKey) throw new Error("Invalid path.");

	// Create a pointer object that traverses the nested properties of the `obj` object based on the `path` provided.
	// If a property does not exist, it will be created as an empty object.
	const pointer = pList.reduce((accumulator: Record<string | number, unknown>, currentValue: string | number) => {
		if (accumulator[currentValue] === undefined) accumulator[currentValue] = {};
		return accumulator[currentValue] as Record<string | number, unknown>;
	}, obj);

	if (!(lastKey in pointer)) throw new Error("Invalid path. This is likely due to a missing array index.");
	if (pointer[lastKey] && typeof pointer[lastKey] !== typeof value)
		throw new Error(`Invalid value type. Expected ${typeof pointer[lastKey]} but got ${typeof value}.`);

	// Set the value of the last key in the pointer object.
	pointer[lastKey] = value;
	return obj;
}
```

#### Example

Using the object from the previous example, we can set the value of the `date` property to a `Date` object, and the value of the `tags[0]` property to a string. We can also see that trying to set the `date` property to a string will result in a type error.

```ts
setValue(logData, "date", new Date("2023-02-01"));
setValue(logData, "tags[0]", "test");
// [!code word:"2024-01-01":1]
setValue(logData, "date", "2024-01-01"); // expected Date, received string // [!code error]
```