---
title: Svelte 5 Methods
description: Useful methods using the new runes feature for Svelte 5
date: 2023-09-20T19:50:04.311Z
image: $/assets/images/runes.png
tags:
  - SvelteKit
  - TypeScript
---

## Table of Contents

## History

This is a simple utility function that can be used to create a history object, which tracks the current value and allows you to undo and redo changes to the value. Set the `maxLength` to `0` to disable the history limit.

<div class="button-row">
  [Preview](btn::https://svelte-5-preview.vercel.app/#H4sIAAAAAAAAE4VUwY6bMBD9FcvdA2hZSCr1QoCqtx62l1Y9hT0QmCTWOgbZQ5oI-d9rYxzY7KrNxfHMvJk3b8YMdM84KJpuByqqE9CUfus6GlG8dvaizsARzF21vaytJVO1ZB0WpShx34saWSvIkSls5TVggiGreERO1eUZxAGPJCdfViEZbDgH9JHG_KCwQgi2E-Yl3PgYJhq4zBGr2VP3UoJA62tAsjM0wZRwO4JcEhMsAXspXNkSDzM0CL3xFjR5Ns6sI3eqBUbAn1-WygI7lY1Vx1kNgaP8SNaR7zDmrv8n105EbklMITL-Zi1u2cZkPyo8xkbBYPVBtpuy4b0z3HhyXsB34PVdk4d5Ih8IM3kWGMv64CfkEK6VCTHap_58jV407TK5J7fs0tkMv_COoIR_gZkI3rfosz0ustlDm4t22-EXcZYoKGlJI_J53LUsmXdcZMd18WzGpjAlg42Op63QWWJcJoCJrkdiH0xeUoQLlpTsDIf0XPEe8rcgkljIrkc0z6YVaW0m_poPpse8GMnETi9d_DZnlrjI_2GcTLr4CW8wjv1312Lq-bZ8fLzDJ6jqo8P7TawUYQgnI6F2ymWcEYVXDmnd8lbmAyO5Ey12Kn8lJTXVTcup-bfjVf1aUl34eQ02nc-VcOYqJ7aytkIbLubjcmobtmfQ0BRlD_pF_wXRuPjClwQAAA==)
</div>

```ts
function history<T>(initial: T, maxLength = 50) {
	let history = $state<T[]>([initial]);
	let index = $state(0);
	let current = $derived(history[index]);

	return {
		get current() { return current },
		set current(newState: T) {
			history.splice(index + 1, history.length - index, newState);
      if (maxLength > 0) history = history.slice(Math.max(0, history.length - maxLength), history.length);
			index = history.length - 1;
		},
		get history() { return history },
    get index() { return index },
		undo() { index = Math.max(0, index - 1) },
		redo() { index = Math.min(history.length - 1, index + 1) }
	};
}
```

## Fetcher

This is a simple utility function that can be used to create a fetcher object. It is a simple wrapper around the `fetch` API that provides reactivity for Svelte 5.

```ts
export function createFetcher<T extends unknown>(url: string) {
	let result = $state<T | null>(null);
	let loading = $state(false);
	let error = $state<string | null>(null);

	const controller = new AbortController();

	$effect(async () => {
		loading = true;
		try {
			const resp = await fetch(url, { signal: controller.signal });
			result = await resp.json();
		} catch {
			error = "Add error message here!";
			result = null;
		}

		loading = false;

		return controller.abort;
	});

	return {
		get result() { return result },
		get loading() { return loading },
		get error() { return error },
		abort(reason?: unknown) { controller.abort(reason) }
	};
}

// Example usage
const x = createFetcher("https://jsonplaceholder.typicode.com/todos/1");

x.result;
x.loading;
x.error;
x.abort();
```

## Websocket

This is a simple utility function that can be used to create a websocket object. It is a simple wrapper around the `WebSocket` API that provides reactivity for Svelte 5.

```ts
export default function createSocket<T>(
	url: string | URL,
	options?: {
		name?: string;
		protocols?: string | string[];
    onOpen?: (event: Event) => void;
    onError?: (error: Event) => void;
		beforeMessage?: (requests: T[]) => void;
		afterMessage?: (requests: T[]) => void;
	}
) {
	let requests = $state<T[]>([]);
	let latest = $derived(requests.at(requests.length - 1));
  let websocket: WebSocket | null = null;

	$effect(() => {
    websocket = new WebSocket(url, options?.protocols)

		websocket.onopen = (event) => {
			console.log(`${options?.name || "Websocket"} connected!`);
      if (options?.onOpen) options.onOpen(event);
		};

		websocket.onerror = (error) => {
			console.log(`${options?.name || "Websocket"} error:`, error);
      if (options?.onError) options.onError(error);
		};

		websocket.onmessage = (event) => {
			if (options?.beforeMessage) options.beforeMessage(requests);
			requests = requests.concat(JSON.parse(event.data) as T);
			if (options?.afterMessage) options.afterMessage(requests);
		};

    return () => {
      if (websocket) websocket.close();
    }
	});

	return {
		get requests() { return requests },
		get latest() { return latest },
		close() {
			if (websocket) websocket.close();
		},
		send(data: T) {
			if (!websocket) throw new Error("No websocket connection");
			if (websocket.readyState !== websocket.OPEN) throw new Error("No websocket connection");
			websocket.send(JSON.stringify(data));
		}
	};
}
```