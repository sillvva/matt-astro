---
title: SvelteKit Remote Functions Techniques
description: A guide to techniques for using remote functions in SvelteKit
date: 2025-11-10T18:16:32.502Z
image: $/assets/images/svelte.webp
tags:
  - SvelteKit
  - TypeScript
  - Forms
---
import TabbedCode from "$/components/markdown/code/tabbed.astro";

## Table of Contents

## Introduction

## Forms

### Discriminated Unions

As the `fields` property of a form instance is a proxy object where the value is returned as a method, you can't use discriminated unions in the normal sense. It will require type assertions to work correctly.

<TabbedCode>
<Fragment slot="tab-1">forms.remote.ts</Fragment>
<Fragment slot="panel-1">
```ts
import * as v from 'valibot';

export type TypeA = v.InferInput<typeof typeA>;
export const typeA = v.object({
  propA: v.string(),
});

export type TypeB = v.InferInput<typeof typeA>;
export const typeB = v.object({
  propB: v.number(),
});

export const schema = v.object({
  diff: v.variant('type', [
    v.object({
      type: v.literal('a'),
      ...typeA.entries,
    }),
    v.object({
      type: v.literal('b'),
      ...typeB.entries,
    }),
  ]),
});
```
</Fragment>
<Fragment slot="tab-2">template.svelte</Fragment>
<Fragment slot="panel-2">
```svelte
{#if myForm.fields.diff.type.value() == "a"}
    {@const diff = myForm.fields.diff as RemoteFormFields<TypeA>}
    PropA: <input {...diff.propA.as("text")}>
{:else}
    {@const diff = myForm.fields.diff as RemoteFormFields<TypeB>}
    PropB: <input {...diff.propB.as("number")}>
{/if}
```
</Fragment>
</TabbedCode>

## Utilities

### Guarded Remote Functions

<TabbedCode>
<Fragment slot="tab-1">$lib/server/remote-utils.ts</Fragment>
<Fragment slot="panel-1">
```ts
import { command, form, getRequestEvent, query } from "$app/server";
import type { StandardSchemaV1 } from "@standard-schema/spec";
import {
	redirect,
	type Invalid,
	type RemoteCommand,
	type RemoteForm,
	type RemoteFormInput,
	type RemoteQueryFunction,
	type RequestEvent
} from "@sveltejs/kit";

const LOGINPAGE = "/";

function isStandardSchema(schema: unknown): schema is StandardSchemaV1 {
	return typeof schema === "object" && schema !== null && "~standard" in schema;
}

// -------------------------------------------------------------------------------------------------
// guardedQuery: Remote Query with auth guard
// -------------------------------------------------------------------------------------------------

export function guardedQuery<Schema extends StandardSchemaV1, Output>(
	schema: Schema,
	fn: (
		output: StandardSchemaV1.InferOutput<Schema>,
		auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }
	) => Promise<Output>
): RemoteQueryFunction<StandardSchemaV1.InferInput<Schema>, Promise<Output>>;

export function guardedQuery<Output>(
	fn: (auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }) => Promise<Output>
): RemoteQueryFunction<void, Promise<Output>>;

export function guardedQuery<Schema extends StandardSchemaV1, Output>(
	schemaOrFn: Schema | ((auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }) => Promise<Output>),
	maybeFn?: (
		output: StandardSchemaV1.InferOutput<Schema>,
		auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }
	) => Promise<Output>
) {
	// Handle the case with schema parameter (first overload)
	if (isStandardSchema(schemaOrFn) && typeof maybeFn === "function") {
		return query(schemaOrFn, (output) => {
			const event = getRequestEvent();
			if (!event.locals.user) redirect(302, LOGINPAGE);
			return maybeFn(output, { user: event.locals.user, event });
		});
	}

	// Handle the case where there's no schema parameter (second overload)
	if (typeof schemaOrFn === "function" && !maybeFn) {
		return query(() => {
			const event = getRequestEvent();
			if (!event.locals.user) redirect(302, LOGINPAGE);
			return schemaOrFn({ user: event.locals.user, event });
		});
	}

	throw new Error("Invalid arguments");
}

// -------------------------------------------------------------------------------------------------
// guardedForm: Remote Form with auth guard
// -------------------------------------------------------------------------------------------------

export function guardedForm<Schema extends StandardSchemaV1<RemoteFormInput, Record<string, unknown>>, Output>(
	schema: Schema,
	fn: (
		output: StandardSchemaV1.InferOutput<Schema>,
		auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent; invalid: Invalid<StandardSchemaV1.InferInput<Schema>> }
	) => Promise<Output>
): RemoteForm<StandardSchemaV1.InferInput<Schema>, Output>;

export function guardedForm<Input extends RemoteFormInput, Output>(
	schema: "unchecked",
	fn: (
		output: Input,
		auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent; invalid: Invalid<Input> }
	) => Promise<Output>
): RemoteForm<Input, Output>;

export function guardedForm<Output>(
	fn: (auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent; invalid: Invalid<void> }) => Promise<Output>
): RemoteForm<void, Output>;

export function guardedForm<
	Schema extends StandardSchemaV1<RemoteFormInput, Record<string, unknown>>,
	Input extends RemoteFormInput,
	Output
>(
	schemaOrFn:
		| "unchecked"
		| Schema
		| ((auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent; invalid: Invalid<void> }) => Promise<Output>),
	maybeFn?:
		| ((
				output: StandardSchemaV1.InferOutput<Schema>,
				auth: {
					user: NonNullable<App.Locals["user"]>;
					event: RequestEvent;
					invalid: Invalid<StandardSchemaV1.InferInput<Schema>>;
				}
		  ) => Promise<Output>)
		| ((
				input: Input,
				auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent; invalid: Invalid<Input> }
		  ) => Promise<Output>)
) {
	// Handle the case with schema parameter (first overload)
	if (isStandardSchema(schemaOrFn) && typeof maybeFn === "function") {
		const fn = maybeFn as (
			output: StandardSchemaV1.InferOutput<Schema>,
			auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent; invalid: Invalid<StandardSchemaV1.InferInput<Schema>> }
		) => Promise<Output>;
		return form(schemaOrFn, async (output, invalid) => {
			const event = getRequestEvent();
			if (!event.locals.user) redirect(302, LOGINPAGE);
			return await fn(output, { invalid, user: event.locals.user, event });
		});
	}

	// Handle the case with unchecked schema parameter (second overload)
	if (typeof schemaOrFn === "string" && typeof maybeFn === "function") {
		const fn = maybeFn as (
			input: Input,
			auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent; invalid: Invalid<Input> }
		) => Promise<Output>;
		return form(schemaOrFn, async (input: Input, invalid) => {
			const event = getRequestEvent();
			if (!event.locals.user) redirect(302, LOGINPAGE);
			return await fn(input, { invalid, user: event.locals.user, event });
		});
	}

	// Handle the case where there's no schema parameter (third overload)
	if (typeof schemaOrFn === "function" && !maybeFn) {
		return form(async (invalid) => {
			const event = getRequestEvent();
			if (!event.locals.user) redirect(302, LOGINPAGE);
			return await schemaOrFn({ invalid, user: event.locals.user, event });
		});
	}

	throw new Error("Invalid arguments");
}

// -------------------------------------------------------------------------------------------------
// guardedCommand: Remote Command with auth guard
// -------------------------------------------------------------------------------------------------

export function guardedCommand<Schema extends StandardSchemaV1, Output>(
	schema: Schema,
	fn: (
		output: StandardSchemaV1.InferOutput<Schema>,
		auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }
	) => Promise<Output>
): RemoteCommand<StandardSchemaV1.InferInput<Schema>, Promise<Output | { redirect: string }>>;

export function guardedCommand<Input, Output>(
	fn: (input: Input, auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }) => Promise<Output>
): RemoteCommand<Input, Promise<Output | { redirect: string }>>;

export function guardedCommand<Schema extends StandardSchemaV1, Input, Output>(
	schemaOrFn: Schema | ((input: Input, auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }) => Promise<Output>),
	maybeFn?: (
		output: StandardSchemaV1.InferOutput<Schema>,
		auth: { user: NonNullable<App.Locals["user"]>; event: RequestEvent }
	) => Promise<Output>
) {
	// Handle the case with schema parameter (first overload)
	if (isStandardSchema(schemaOrFn) && typeof maybeFn === "function") {
		return command(schemaOrFn, async (output) => {
			const event = getRequestEvent();
			if (!event.locals.user) return { redirect: LOGINPAGE };
			return await maybeFn(output, { user: event.locals.user, event });
		});
	}

	// Handle the case where there's no schema parameter (second overload)
	if (typeof schemaOrFn === "function" && !maybeFn) {
		return command("unchecked", async (input: Input) => {
			const event = getRequestEvent();
			if (!event.locals.user) return { redirect: LOGINPAGE };
			return await schemaOrFn(input, { user: event.locals.user, event });
		});
	}

	throw new Error("Invalid arguments");
}
```
</Fragment>
</TabbedCode>

#### Lint Rule to Enforce Guarded Remote Functions

<TabbedCode>
<Fragment slot="tab-1">eslint.config.js</Fragment>
<Fragment slot="panel-1">
```js
import js from "@eslint/js";
import eslintConfigPrettier from "eslint-config-prettier/flat";
import svelte from "eslint-plugin-svelte";
import globals from "globals";
import enforceGuardedExports from "./eslint/enforce-guarded-functions.js";// [!code ++]
import svelteConfig from "./svelte.config.js";

// Use the typescript-eslint aggregator for flat config presets
// (requires devDependency: "typescript-eslint")
import tseslint from "typescript-eslint";

export default [
  ... // existing rules
  
  // [!code ++:13]
	{
		files: ["**/*.remote.ts"],
		plugins: {
			custom: {
				rules: {
					"enforce-guarded-functions": enforceGuardedExports
				}
			}
		},
		rules: {
			"custom/enforce-guarded-functions": "error"
		}
	}
];
```
</Fragment>
<Fragment slot="tab-2">enforce-guarded-remote-functions.js</Fragment>
<Fragment slot="panel-2">
```js
export default {
	meta: {
		type: "problem",
		docs: {
			description: "Enforce that exports in .remote.ts files use guardedQuery(), guardedCommand(), or guardedForm()",
			category: "Best Practices",
			recommended: true
		},
		messages: {
			unguardedExport:
				"Exports in .remote.ts files must use guardedQuery(), guardedCommand(), or guardedForm(). Direct exports of query(), command(), or form() are not allowed.",
			mustBeGuarded: 'Export "{{name}}" must be the return value of guardedQuery(), guardedCommand(), or guardedForm().'
		},
		schema: []
	},

	create(context) {
		const filename = context.getFilename();

		// Only apply this rule to files ending in .remote.ts
		if (!filename.endsWith(".remote.ts")) {
			return {};
		}

		const guardedFunctions = new Set(["guardedQuery", "guardedCommand", "guardedForm"]);
		const unguardedFunctions = new Set(["query", "command", "form"]);

		function isGuardedCall(node) {
			return node.type === "CallExpression" && node.callee.type === "Identifier" && guardedFunctions.has(node.callee.name);
		}

		function isUnguardedCall(node) {
			return node.callee.type === "Identifier" && unguardedFunctions.has(node.callee.name);
		}

		function checkExportDeclaration(node) {
			if (node.type === "ExportNamedDeclaration") {
				if (node.declaration && node.declaration.type === "VariableDeclaration") {
					for (const declarator of node.declaration.declarations) {
						if (declarator.init) {
							if (declarator.init.type === "CallExpression" && isUnguardedCall(declarator.init)) {
								context.report({
									node: declarator.init,
									messageId: "unguardedExport"
								});
							} else if (!isGuardedCall(declarator.init)) {
								context.report({
									node: declarator,
									messageId: "mustBeGuarded",
									data: {
										name: declarator.id.name
									}
								});
							}
						}
					}
				}
			}
		}

		return {
			ExportNamedDeclaration: checkExportDeclaration
		};
	}
};
```
</Fragment>
</TabbedCode>

