---
title: Redis Data Cache
description: Functions that make working with a Redis data cache simple
date: 2023-08-24T15:32:12Z
updated: 2024-02-23T23:02:47.026Z
image: $/assets/images/R.webp
tags:
  - TypeScript
  - Database
  - Redis
---

## Table of Contents

## The Functions

Aside from cold starts, often the slowest part of an application is fetching data. Caching data requests can speed up loading times. Using an internal store is one way to do it, or you can use a Redis cache. These functions can make working with a Redis cache extremely simple.

If the Redis connection is lost or not ready, the functions will use the callback function on each call instead as a fallback to prevent the application from crashing.

```typescript
// $lib/server/cache.ts
import { REDIS_URL } from "$env/static/private";
import { Redis } from "ioredis";

let redis: Redis;
let status = "";
function connect() {
	if (["ready", "connect", "connecting", "reconnecting"].includes(status)) return;
	status = "connecting";
	try {
		redis = new Redis(REDIS_URL, {
			retryStrategy: function (times) {
				status = redis.status || "";
				const delay = Math.min(times * 2000, 10000);
				if (times >= 10) return;
				return delay;
			}
		});
	} catch (e) {
		console.error("Redis connection failed:", e);
	}
}

connect();

async function readyCheck<T>(callback: () => Promise<T>) {
	status = redis?.status || "";
	if (!redis || !["ready"].includes(status)) {
		console.log("Redis status:", status);
		connect();
		return await callback();
	}
	return;
}

/**
 * A cache key as an array of strings with at least one element.
 */
export type CacheKey = [string, ...string[]];

/**
 * Retrieves a cache from Redis or caches the results of a callback function.
 * @template TReturnType The return type of the callback function.
 * @param [callback] The callback function to cache.
 * @param [key] The cache key as an array of strings.
 * @param [expires=259200] The cache expiration time in seconds. Defaults to 3 days.
 * @returns The cached result of the callback function.
 */
export async function cache<TReturnType>(callback: () => Promise<TReturnType>, key: CacheKey, expires = 3 * 86400) {
	const check = await readyCheck(async () => await callback());
	if (check) return check;

	const rkey = key.join("|");
	const currentTime = Date.now();

	// Get the cache from Redis
	const cache = JSON.parse((await redis.get(rkey)) || "null") as { data: TReturnType; timestamp: number } | null;

	if (cache) {
		// Update the timestamp and reset the cache expiration
		cache.timestamp = currentTime;
		redis.setex(rkey, expires, JSON.stringify(cache));

		return cache.data;
	}

	// Call the callback function and cache the result
	const result = await callback();
	redis.setex(rkey, expires, JSON.stringify({ data: result, timestamp: currentTime }));
	return result;
}

/**
 * Retrieves caches from Redis or caches the results of a callback function for each key.
 * @template TReturnType The return type of the callback function.
 * @param [callback] The callback function to cache. The hits parameter is an array of cached results of the callback function for each key.
 * @param [keys] The cache keys as an array of arrays of strings.
 * @param [expires=259200] The cache expiration time in seconds. Defaults to 3 days.
 * @returns An array of cached results of the callback function for each key.
 */
export async function mcache<TReturnType extends object>(
	callback: (keys: CacheKey[], hits: TReturnType[]) => Promise<Array<{ key: CacheKey; value: TReturnType }>>,
	keys: CacheKey[],
	expires = 3 * 86400
) {
	const check = await readyCheck(() => callback(keys, []).then((t) => t.map((t) => t.value)));
	if (check) return check;

	const joinedKeys = keys.map((t) => t.join("|"));

	// Get the caches from Redis
	const caches = await redis.mget(joinedKeys);
	const hits = caches.filter(Boolean) as string[];

	if (hits.length < keys.length) {
		// Call the mass callback function
		const results = await callback(
			keys,
			hits.map((t) => {
				const cache: { data: TReturnType; timestamp: number } = JSON.parse(t);
				return cache.data;
			})
		);

		// Update the results in the caches array
		for (const result of results) {
			const k = result.key.join("|");
			const index = joinedKeys.indexOf(k);
			if (index >= 0) caches[index] = JSON.stringify({ data: result.value, timestamp: Date.now() });
		}
	}

	const multi = redis.multi();
	const results: TReturnType[] = [];
	for (let i = 0; i < caches.length; i++) {
		const currentTime = Date.now();
		const value = caches[i];
		if (value) {
			try {
				const cache: { data: TReturnType; timestamp: number } = JSON.parse(value);

				// Update the timestamp and reset the cache expiration
				cache.timestamp = currentTime;
				multi.setex(joinedKeys[i], expires, JSON.stringify(cache));

				// Add the cached result to the results array
				results.push(cache.data);
				continue;
			} catch (e) {
				console.error(e);
			}
		}
	}

	multi.exec();

	// Return the results
	return results;
}

/**
 * Invalidates Redis caches based on an array of keys.
 * @param [keys] The cache keys as an array of arrays of strings. Empty strings, false, null, and undefined are ignored.
 */
export function revalidateKeys(keys: Array<CacheKey | "" | false | null | undefined>) {
	if (!redis || !["ready"].includes(redis.status)) return connect();

	const cacheKeys = keys.filter((t) => Array.isArray(t) && t.length).map((t) => (t as string[]).join("|"));
	if (cacheKeys.length) redis.del(...cacheKeys);
}
```

### Example

To show how simple these functions are to use, here is an example:

```typescript
import { cache, mcache, type CacheKey } from "$/server/cache";
import { prisma } from "$/server/db";

// A function which fetches data from a DB or API
export async function getModel(id: string): Model | null {
  return await prisma.model.findFirst({
    where: { id }
  });
}

// A function which checks for and returns a cache
// or calls a callback function and fetches and returns
// the result.
export async function getModelCache(id: string) {
	return await cache(() => getModel(id), ["model", id]);
	//           ^? Model | null
}

// A function which checks for and returns multiple caches
// or calls a callback function and fetches and returns the
// result for each key.
export async function getModelCaches(ids: string[]) {
  const keys: Array<CacheKey> = ids.map((id) => ["model", id]);
	return await mcache((key) => getModel(key[1]), keys);
	//           ^? Array<Model | null>
}
```